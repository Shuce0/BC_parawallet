"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizePhoneNumber = exports.stringToPhoneNumber = exports.truncateAddress = exports.getCosmosAddress = exports.decimalToHex = exports.hexToDecimal = exports.hexToUint8Array = exports.hexToSignature = exports.hexStringToBase64 = void 0;
const encoding_1 = require("@cosmjs/encoding");
const sha256_1 = require("@noble/hashes/sha256");
const ripemd160_1 = require("@noble/hashes/ripemd160");
const elliptic_1 = __importDefault(require("elliptic"));
const libphonenumber_js_1 = __importDefault(require("libphonenumber-js"));
const secp256k1 = new elliptic_1.default.ec('secp256k1');
function hexStringToBase64(hexString) {
    if (hexString.substring(0, 2) === '0x') {
        hexString = hexString.substring(2);
    }
    return Buffer.from(hexString, 'hex').toString('base64');
}
exports.hexStringToBase64 = hexStringToBase64;
function hexToSignature(hexSig) {
    return {
        r: `0x${hexSig.slice(2, 66)}`,
        s: `0x${hexSig.slice(66, 130)}`,
        v: BigInt(hexSig.slice(130, 132)),
    };
}
exports.hexToSignature = hexToSignature;
function hexToUint8Array(hex) {
    if (hex.startsWith('0x')) {
        hex = hex.slice(2);
    }
    return new Uint8Array(Buffer.from(hex, 'hex'));
}
exports.hexToUint8Array = hexToUint8Array;
function hexToDecimal(hex) {
    if (hex.startsWith('0x')) {
        hex = hex.slice(2);
    }
    return `${parseInt(hex, 16)}`;
}
exports.hexToDecimal = hexToDecimal;
function decimalToHex(decimal) {
    return `0x${parseInt(decimal).toString(16)}`;
}
exports.decimalToHex = decimalToHex;
function compressPubkey(pubkey) {
    switch (pubkey.length) {
        case 33:
            return pubkey;
        case 65:
            return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(true, 'array'));
        default:
            throw new Error('Invalid pubkey length');
    }
}
function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
    if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
    }
    return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(pubkeyData));
}
function getCosmosAddress(publicKey, prefix) {
    const uncompressedPublicKey = new Uint8Array(Buffer.from(publicKey.startsWith('0x') ? publicKey.slice(2) : publicKey, 'hex'));
    const compressedPublicKey = compressPubkey(uncompressedPublicKey);
    return (0, encoding_1.toBech32)(prefix, rawSecp256k1PubkeyToRawAddress(compressedPublicKey));
}
exports.getCosmosAddress = getCosmosAddress;
function truncateAddress(str, addressType, { prefix = addressType === 'COSMOS' ? 'cosmos' : undefined } = {}) {
    const headLength = (addressType === 'COSMOS' ? prefix.length : addressType === 'SOLANA' ? 0 : 2) + 4;
    return `${str.slice(0, headLength)}...${str.slice(-4)}`;
}
exports.truncateAddress = truncateAddress;
function stringToPhoneNumber(str) {
    var _a;
    return (_a = (0, libphonenumber_js_1.default)(str)) === null || _a === void 0 ? void 0 : _a.formatInternational().replace(/[^\d+]/g, '');
}
exports.stringToPhoneNumber = stringToPhoneNumber;
function normalizePhoneNumber(countryCode, number) {
    return stringToPhoneNumber(`${countryCode[0] !== '+' ? '+' : ''}${countryCode}${number}`);
}
exports.normalizePhoneNumber = normalizePhoneNumber;
