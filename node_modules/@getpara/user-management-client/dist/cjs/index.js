var te=Object.create;var P=Object.defineProperty;var re=Object.getOwnPropertyDescriptor;var ae=Object.getOwnPropertyNames;var ne=Object.getPrototypeOf,ie=Object.prototype.hasOwnProperty;var oe=(r,e)=>{for(var s in e)P(r,s,{get:e[s],enumerable:!0})},A=(r,e,s,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of ae(e))!ie.call(r,a)&&a!==s&&P(r,a,{get:()=>e[a],enumerable:!(t=re(e,a))||t.enumerable});return r};var x=(r,e,s)=>(s=r!=null?te(ne(r)):{},A(e||!r||!r.__esModule?P(s,"default",{value:r,enumerable:!0}):s,r)),le=r=>A(P({},"__esModule",{value:!0}),r);var pe={};oe(pe,{AuthMethod:()=>_,Chain:()=>Z,EmailTheme:()=>V,EncryptorType:()=>k,KeyShareType:()=>N,NON_ED25519:()=>ge,Network:()=>j,OAuthMethod:()=>H,OnRampAsset:()=>Y,OnRampProvider:()=>F,OnRampPurchaseStatus:()=>z,OnRampPurchaseType:()=>Q,PREGEN_IDENTIFIER_TYPES:()=>ye,PasswordStatus:()=>D,PublicKeyStatus:()=>M,PublicKeyType:()=>G,WalletScheme:()=>J,WalletType:()=>X,default:()=>de,extractAuthInfo:()=>ce,extractWalletRef:()=>f,handleResponseError:()=>K,handleResponseSuccess:()=>L,isEmail:()=>$,isExternalWalletAddress:()=>S,isFarcaster:()=>q,isPhone:()=>O,isTelegram:()=>C,isUserId:()=>W,isWalletId:()=>T});module.exports=le(pe);var y=x(require("axios")),w=x(require("qs"));function T(r){return!!r.walletId&&!r.externalWalletAddress}function S(r){return!!r.externalWalletAddress&&!r.walletId}function f(r){if(T(r))return["walletId",r.walletId];if(S(r))return["externalWalletAddress",r.externalWalletAddress];throw new Error("invalid wallet params")}function l(r){return!!r&&r!=="null"&&r!=="undefined"&&r!==""}function $(r){return l(r.email)&&!l(r.phone)&&!l(r.countryCode)&&!l(r.farcasterUsername)&&!l(r.telegramUserId)}function O(r){return l(r.phone)&&l(r.countryCode)&&!l(r.email)&&!l(r.farcasterUsername)&&!l(r.telegramUserId)}function q(r){return l(r.farcasterUsername)&&!l(r.email)&&!l(r.phone)&&!l(r.countryCode)&&!l(r.telegramUserId)}function C(r){return l(r.telegramUserId)&&!l(r.email)&&!l(r.phone)&&!l(r.countryCode)&&!l(r.farcasterUsername)}function W(r){return l(r.userId)&&!l(r.email)&&!l(r.phone)&&!l(r.countryCode)&&!l(r.farcasterUsername)&&!l(r.telegramUserId)}function ce(r,{allowUserId:e=!1,isRequired:s=!1}={}){switch(!0){case $(r):return{auth:{email:r.email},authType:"email",identifier:r.email,publicKeyIdentifier:r.email};case O(r):return{auth:{phone:r.phone,countryCode:r.countryCode},authType:"phone",identifier:`${r.countryCode}${r.phone}`,publicKeyIdentifier:`${r.countryCode}${r.phone}`};case q(r):return{auth:{farcasterUsername:r.farcasterUsername},authType:"farcaster",identifier:r.farcasterUsername,publicKeyIdentifier:`${r.farcasterUsername}-farcaster`};case C(r):return{auth:{telegramUserId:r.telegramUserId},authType:"telegram",identifier:r.telegramUserId,publicKeyIdentifier:`${r.telegramUserId}-telegram`};case(W(r)&&e):return{auth:{userId:r.userId},authType:"userId",identifier:r.userId,publicKeyIdentifier:r.userId};default:if(s)throw new Error("invalid auth object");return}}var E="x-capsule-sid",v="x-para-version",h="x-partner-id",U="X-External-API-Key";function m(r,e,s,t){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error().stack,this.message=r,this.name="ParaApiError",e&&(this.code=e),s&&(this.status=s),t&&(this.responseURL=t)}var ue=m.prototype;Object.defineProperty(ue,"isParaApiError",{value:!0});var L=r=>{if(r.status===200)return r;throw new m("Invalid status code")},K=r=>{if(r===null)throw new m("Error is null");if(y.default.isAxiosError(r)){let e=r.response?.data??"Unknown error";throw r.code==="ERR_NETWORK"?e="Connection error":r.code==="ERR_CANCELED"&&(e="Connection canceled"),new m(e,r.code,r.response.status,r.request?.responseURL)}throw new m("Unknown error")},b=class{constructor({userManagementHost:e,apiKey:s,partnerId:t,version:a,opts:i,retrieveSessionCookie:o,persistSessionCookie:c}){this.createUser=async e=>(await this.baseRequest.post("/users",e)).data;this.checkUserExists=async e=>await this.baseRequest.get("/users/exists",{params:{...e}});this.verifyTelegram=async e=>(await this.baseRequest.post("/users/telegram",{authObject:e})).data;this.externalWalletLogin=async e=>(await this.baseRequest.post("/users/external-wallets/login",e)).data;this.verifyEmail=async(e,s)=>await this.baseRequest.post(`/users/${e}/verify-email`,s);this.verifyPhone=async(e,s)=>await this.baseRequest.post(`/users/${e}/verify-identifier`,s);this.addSessionPublicKey=async(e,s)=>await this.baseRequest.post(`/users/${e}/biometrics/key`,s);this.getSessionPublicKeys=async e=>await this.baseRequest.get(`/users/${e}/biometrics/keys`);this.getBiometricLocationHints=async e=>(await this.baseRequest.get("/biometrics/location-hints",{params:e})).data.hints;this.getSessionPublicKey=async(e,s)=>await this.baseRequest.get(`/users/${e}/biometrics/${s}`);this.patchSessionPublicKey=async(e,s,t,a)=>await this.baseRequest.patch(`/users/${s}/biometrics/${t}`,a,{headers:{[h]:e}});this.getWebChallenge=async e=>(await this.baseRequest.get("/biometrics/challenge",{params:{...e||{}}})).data;this.touchSession=async e=>await this.baseRequest.post(`/touch?regenerate=${!!e}`);this.sessionOrigin=async e=>(await this.baseRequest.get(`/sessions/${e}/origin`)).data;this.verifyWebChallenge=async(e,s)=>await this.baseRequest.post("/biometrics/verify",s,{headers:{[h]:e}});this.getSessionChallenge=async e=>await this.baseRequest.get(`/users/${e}/biometrics/challenge`);this.verifySessionChallenge=async(e,s)=>await this.baseRequest.post(`/users/${e}/biometrics/verify`,s);this.createWallet=async(e,s)=>(await this.baseRequest.post(`/users/${e}/wallets`,s)).data;this.createPregenWallet=async e=>(await this.baseRequest.post("/wallets/pregen",e)).data;this.getPregenWallets=async(e,s=!1,t)=>(await this.baseRequest.get("/wallets/pregen",{params:{ids:e,expand:s,userId:t}})).data;this.claimPregenWallets=async e=>(await this.baseRequest.post("/wallets/pregen/claim",e)).data;this.sendTransaction=async(e,s,t)=>await this.baseRequest.post(`/users/${e}/wallets/${s}/transactions/send`,t);this.signTransaction=async(e,s,t)=>await this.baseRequest.post(`/users/${e}/wallets/${s}/transactions/sign`,t);this.refreshKeys=async(e,s,t,a,i)=>{let o={oldPartnerId:t,newPartnerId:a,keyShareProtocolId:i};return await this.baseRequest.post(`/users/${e}/wallets/${s}/refresh`,o)};this.updatePregenWallet=async(e,s)=>(await this.baseRequest.patch(`/wallets/pregen/${e}`,s)).data;this.getWallets=async(e,s)=>await this.baseRequest.get(`/users/${e}/wallets${s?`?includePartnerData=${encodeURIComponent(s)}`:""}`);this.getAllWallets=async e=>await this.baseRequest.get(`/users/${e}/all-wallets`);this.setCurrentWalletIds=async(e,s,t=!1,a,i)=>await this.baseRequest.post(`/users/${e}/wallets/set`,{walletIds:s,needsWallet:t,sessionLookupId:a,newDeviceSessionLookupId:i});this.login=async e=>{let s=e;return await this.baseRequest.post("/login",s)};this.verifyLogin=async e=>{let s={verificationCode:e};return await this.baseRequest.post("/login/verify-email",s)};this.logout=async()=>await this.baseRequest.get("/logout");this.recoveryVerification=async(e,s)=>{let t={email:e,verificationCode:s};return await this.baseRequest.post("/recovery/verification",t)};this.recoveryInit=async e=>{let s={email:e};return await this.baseRequest.post("/recovery",s)};this.preSignMessage=async(e,s,t,a,i)=>{let o={message:t,scheme:a,cosmosSignDoc:i};return(await this.baseRequest.post(`/users/${e}/wallets/${s}/messages/sign`,o)).data};this.deleteSelf=async e=>await this.baseRequest.delete(`/users/${e}`);this.getParaShare=async(e,s)=>(await this.baseRequest.get(`/users/${e}/wallets/${s}/capsule-share`)).data.share;this.getBackupKit=async e=>await this.baseRequest.get(`/download-backup-kit/${e}`,{responseType:"blob"});this.patchSessionPassword=async(e,s,t,a)=>await this.baseRequest.patch(`/users/${s}/passwords/${t}`,a,{headers:{[h]:e}});let d={...s&&{[U]:s},...t&&{[h]:t}},p={baseURL:e,withCredentials:!0,headers:d};if(o){let n=Array.isArray(y.default.defaults.transformRequest)?y.default.defaults.transformRequest:[y.default.defaults.transformRequest];p.transformRequest=[function(u,g){let R=o();return R&&(g[E]=R),a&&(g[v]=a),u},...n]}if(c){let n=Array.isArray(y.default.defaults.transformResponse)?y.default.defaults.transformResponse:[y.default.defaults.transformResponse];p.transformResponse=[...n,function(u,g,R){return g?.[E]&&c(g[E]),u}]}this.baseRequest=y.default.create(p),i?.useFetchAdapter&&(y.default.defaults.adapter=function(n){return fetch(n.baseURL+n.url.substring(1),{method:n.method,headers:n.headers,body:n.data,credentials:n.withCredentials?"include":void 0}).then(u=>u.text().then(g=>({data:g,status:u.status,statusText:u.statusText,headers:u.headers,config:n,request:fetch}))).catch(function(u){throw u})}),this.baseRequest.interceptors.response.use(L,K)}async uploadKeyshares(e,s,t){let a={keyShares:t};return await this.baseRequest.post(`/users/${e}/wallets/${s}/key-shares`,a)}async uploadUserKeyShares(e,s){let t={keyShares:s};return await this.baseRequest.post(`/users/${e}/key-shares`,t)}async getKeyshare(e,s,t,a){return await this.baseRequest.get(`/users/${e}/wallets/${s}/key-shares?type=${t}${a?`&encryptor=${a}`:""}`)}async getBiometricKeyshares(e,s,t){return await this.baseRequest.get(`/users/${e}/biometrics/key-shares?publicKey=${s}&all=${!!t}`)}async getPasswordKeyshares(e,s,t){return await this.baseRequest.get(`/users/${e}/passwords/key-shares?passwordId=${s}&all=${!!t}`)}async uploadTransmissionKeyshares(e,s){let t={shares:s};return await this.baseRequest.post(`/users/${e}/temporary-shares`,t)}async getTransmissionKeyshares(e,s){return await this.baseRequest.get(`/users/${e}/temporary-shares?sessionLookupId=${s}`)}async resendVerificationCode({userId:e,...s}){return await this.baseRequest.post(`/users/${e}/resend-verification-code`,s)}async resendVerificationCodeByPhone({userId:e,...s}){return await this.baseRequest.post(`/users/${e}/resend-verification-code-by-phone`,s)}async cancelRecoveryAttempt(e){return await this.baseRequest.post("/recovery/cancel",{email:e})}async check2FAStatus(e){return await this.baseRequest.get(`/2fa/users/${e}/check-status`)}async enable2FA(e,s){return await this.baseRequest.post(`/2fa/users/${e}/enable`,{verificationCode:s})}async setup2FA(e){return await this.baseRequest.post(`/2fa/users/${e}/setup`)}async initializeRecovery(e){return await this.baseRequest.post("/recovery/init",{email:e})}async initializeFarcasterLogin(){return await this.baseRequest.post("/auth/farcaster/init")}async getFarcasterAuthStatus(){return await this.baseRequest.post("/auth/farcaster/status")}async initializeRecoveryForPhone(e,s){return await this.baseRequest.post("/recovery/init",{phone:e,countryCode:s})}async finalizeRecovery(e,s){return await this.baseRequest.post(`/recovery/users/${e}/wallets/${s}/finish`)}async recoverUserShares(e,s){return await this.baseRequest.get(`/recovery/users/${e}/wallets/${s}/key-shares?type=USER&encryptor=RECOVERY`)}async verifyEmailForRecovery(e,s){let t={email:e,verificationCode:s};return await this.baseRequest.post("/recovery/verify-email",t)}async verifyPhoneForRecovery(e,s,t){let a={phone:e,countryCode:s,verificationCode:t};return await this.baseRequest.post("/recovery/verify-identifier",a)}async verify2FA(e,s){let t={email:e,verificationCode:s};return await this.baseRequest.post("/2fa/verify",t)}async verify2FAForPhone(e,s,t){let a={phone:e,countryCode:s,verificationCode:t};return await this.baseRequest.post("/2fa/verify",a)}async tempTrasmissionInit(e,s){let t={message:e,userId:s};return await this.baseRequest.post("/temporary-transmissions",t)}async tempTrasmission(e){return await this.baseRequest.get(`/temporary-transmissions/${e}`)}async getPartner(e){return await this.baseRequest.get(`/partners/${e}`)}async acceptScopes(e,s,t){return await this.baseRequest.post(`/users/${e}/wallets/${s}/scopes/accept`,t)}async getPendingTransaction(e,s){return await this.baseRequest.get(`/users/${e}/pending-transactions/${s}`)}async acceptPendingTransaction(e,s){return await this.baseRequest.post(`/users/${e}/pending-transactions/${s}/accept`)}async getOnRampConfig(){return(await this.baseRequest.get("/on-ramp-config")).data}async createOnRampPurchase({userId:e,params:{type:s,walletType:t,address:a,provider:i,networks:o,assets:c,defaultNetwork:d,defaultAsset:p,fiat:n,fiatQuantity:u,testMode:g=!1},...R}){let[ee,I]=f(R),se=ee==="walletId"?`wallets/${I}`:`external-wallets/${I}`;return(await this.baseRequest.post(`/users/${e}/${se}/purchases`,{type:s,provider:i,walletType:t,address:a,networks:o,assets:c,defaultAsset:p,defaultNetwork:d,fiat:n,fiatQuantity:u,testMode:g})).data}async updateOnRampPurchase({userId:e,purchaseId:s,updates:t,...a}){let[i,o]=f(a),c=i==="walletId"?`wallets/${o}`:`external-wallets/${o}`;return(await this.baseRequest.patch(`/users/${e}/${c}/purchases/${s}`,t)).data}async getOnRampPurchase({userId:e,purchaseId:s,...t}){let[a,i]=f(t),o=a==="walletId"?`wallets/${i}`:`external-wallets/${i}`;return await this.baseRequest.get(`/users/${e}/${o}/purchases/${s}`)}async signMoonPayUrl(e,{url:s,type:t,cosmosPrefix:a,testMode:i,walletId:o,externalWalletAddress:c}){let d=o?`wallets/${o}`:`external-wallets/${c}`;return await this.baseRequest.post(`/users/${e}/${d}/moonpay-sign`,{url:s,type:t,cosmosPrefix:a,testMode:i})}async generateOffRampTx(e,{provider:s,chainId:t,contractAddress:a,testMode:i,walletId:o,walletType:c,destinationAddress:d,sourceAddress:p,assetQuantity:n}){return(await this.baseRequest.post(`/users/${e}/wallets/${o}/offramp-generate`,{provider:s,testMode:i,chainId:t,contractAddress:a,walletId:o,walletType:c,destinationAddress:d,sourceAddress:p,assetQuantity:n})).data}async sendOffRampTx(e,{tx:s,signature:t,network:a,walletId:i,walletType:o}){return(await this.baseRequest.post(`/users/${e}/wallets/${i}/offramp-send`,{tx:s,signature:t,network:a,walletType:o})).data}async distributeParaShare({userId:e,walletId:s,...t}){let a=t;return await this.baseRequest.post(`/users/${e}/wallets/${s}/capsule-share/distribute`,a)}async keepSessionAlive(e){return(await this.baseRequest.post(`/users/${e}/session/keep-alive`)).data}async persistRecoveryPublicKeys(e,s){return(await this.baseRequest.post(`/users/${e}/recovery-public-keys`,{publicKeys:s})).data}async getRecoveryPublicKeys(e){return(await this.baseRequest.get(`/users/${e}/recovery-public-keys`)).data}async uploadEncryptedWalletPrivateKey(e,s,t,a,i){let o={encryptedWalletPrivateKey:s,encryptionKeyHash:t,biometricPublicKey:a,passwordId:i};return(await this.baseRequest.post(`/users/${e}/encrypted-wallet-private-keys`,o)).data}async getEncryptedWalletPrivateKeys(e,s){return(await this.baseRequest.get(`/users/${e}/encrypted-wallet-private-keys/${s}`)).data}async getConversionRate(e,s,t){let a={symbol:s,currency:t};return(await this.baseRequest.get(`/chains/${e}/conversion-rate`,{params:a})).data}async getGasEstimate(e,s){let t={totalGasPrice:s};return(await this.baseRequest.get(`/chains/${e}/gas-estimate`,{params:t})).data}async getGasOracle(e){return(await this.baseRequest.get(`/chains/${e}/gas-oracle`)).data}async isRefreshDone(e,s,t,a){let i={};t&&(i.partnerId=t),a&&(i.protocolId=a);let o=w.default.stringify(i);return(await this.baseRequest.get(`/users/${e}/wallets/${s}/refresh-done?${o}`)).data}async deletePendingTransaction(e,s){return(await this.baseRequest.delete(`/users/${e}/pending-transactions/${s}`)).data}async addSessionPasswordPublicKey(e,s){return await this.baseRequest.post(`/users/${e}/passwords/key`,s)}async getSupportedAuthMethods(e){return(await this.baseRequest.get("/users/supported-auth-methods",{params:{...e}})).data}async getPasswords(e){return(await this.baseRequest.get("/users/passwords",{params:{...e}})).data.passwords}async verifyPasswordChallenge(e,s){return await this.baseRequest.post("/passwords/verify",s,{headers:{[h]:e}})}async getEncryptedWalletPrivateKey(e){let s={};s.passwordId=e;let t=w.default.stringify(s);return await this.baseRequest.get(`/encrypted-wallet-private-keys?${t}`)}async getUser(e){return(await this.baseRequest.get(`/users/${e}`)).data}},B=b;var k=(a=>(a.USER="USER",a.RECOVERY="RECOVERY",a.BIOMETRICS="BIOMETRICS",a.PASSWORD="PASSWORD",a))(k||{}),N=(s=>(s.USER="USER",s.RECOVERY="RECOVERY",s))(N||{}),D=(s=>(s.PENDING="PENDING",s.COMPLETE="COMPLETE",s))(D||{}),M=(s=>(s.PENDING="PENDING",s.COMPLETE="COMPLETE",s))(M||{}),G=(s=>(s.MOBILE="MOBILE",s.WEB="WEB",s))(G||{}),H=(c=>(c.GOOGLE="GOOGLE",c.TWITTER="TWITTER",c.APPLE="APPLE",c.DISCORD="DISCORD",c.FACEBOOK="FACEBOOK",c.FARCASTER="FARCASTER",c.TELEGRAM="TELEGRAM",c))(H||{}),_=(s=>(s.PASSWORD="PASSWORD",s.PASSKEY="PASSKEY",s))(_||{});var V=(s=>(s.LIGHT="light",s.DARK="dark",s))(V||{});var F=(t=>(t.RAMP="RAMP",t.STRIPE="STRIPE",t.MOONPAY="MOONPAY",t))(F||{}),Y=(n=>(n.ETHEREUM="ETHEREUM",n.USDC="USDC",n.TETHER="TETHER",n.POLYGON="POLYGON",n.SOLANA="SOLANA",n.ATOM="ATOM",n.CELO="CELO",n.CUSD="CUSD",n.CEUR="CEUR",n.CREAL="CREAL",n))(Y||{}),z=(t=>(t.INITIATED="INITIATED",t.FINISHED="FINISHED",t.CANCELLED="CANCELLED",t))(z||{}),Q=(s=>(s.BUY="BUY",s.SELL="SELL",s))(Q||{});var J=(t=>(t.DKLS="DKLS",t.CGGMP="CGGMP",t.ED25519="ED25519",t))(J||{}),X=(t=>(t.EVM="EVM",t.SOLANA="SOLANA",t.COSMOS="COSMOS",t))(X||{}),Z=(t=>(t.ETH="ETH",t.CELO="CELO",t.MATIC="MATIC",t))(Z||{}),j=(n=>(n.ETHEREUM="ETHEREUM",n.SEPOLIA="SEPOLIA",n.ARBITRUM="ARBITRUM",n.BASE="BASE",n.OPTIMISM="OPTIMISM",n.POLYGON="POLYGON",n.SOLANA="SOLANA",n.COSMOS="COSMOS",n.CELO="CELO",n.NOBLE="NOBLE",n))(j||{}),ye=["EMAIL","PHONE","CUSTOM_ID","DISCORD","TWITTER","TELEGRAM"],ge=["DKLS","CGGMP"];var de=B;0&&(module.exports={AuthMethod,Chain,EmailTheme,EncryptorType,KeyShareType,NON_ED25519,Network,OAuthMethod,OnRampAsset,OnRampProvider,OnRampPurchaseStatus,OnRampPurchaseType,PREGEN_IDENTIFIER_TYPES,PasswordStatus,PublicKeyStatus,PublicKeyType,WalletScheme,WalletType,extractAuthInfo,extractWalletRef,handleResponseError,handleResponseSuccess,isEmail,isExternalWalletAddress,isFarcaster,isPhone,isTelegram,isUserId,isWalletId});
