import Client, { AuthMethod, BackupKitEmailProps, CurrentWalletIds, EmailTheme, WalletEntity, WalletType, WalletParams, OAuthMethod, OnRampPurchaseCreateParams, OnRampPurchase, TPregenIdentifierType, PregenIds, BiometricLocationHint, TelegramAuthResponse, VerifyTelegramRes, Auth } from '@getpara/user-management-client';
import type { pki as pkiType } from 'node-forge';
import { Ctx, Environment, Theme, FullSignatureRes, ExternalWalletInfo, GetWebAuthUrlForLoginParams, AccountSetupResponse, LoginResponse, WalletFilters, WalletTypeProp, Wallet, SupportedWalletTypes, PortalUrlOptions, ConstructorOpts, RecoveryStatus } from './types/index.js';
import { PlatformUtils } from './PlatformUtils.js';
import { CountryCallingCode } from 'libphonenumber-js';
export declare abstract class ParaCore {
    #private;
    static version?: string;
    ctx: Ctx;
    email?: string;
    phone?: string;
    countryCode?: CountryCallingCode;
    farcasterUsername?: string;
    telegramUserId?: string;
    userId?: string;
    private sessionCookie?;
    private isAwaitingAccountCreation;
    private isAwaitingLogin;
    private isAwaitingFarcaster;
    private isAwaitingOAuth;
    get isEmail(): boolean;
    get isPhone(): boolean;
    get isFarcaster(): boolean;
    get isTelegram(): boolean;
    /**
     * The IDs of the currently active wallets, for each supported wallet type. Any signer integrations will default to the first viable wallet ID in this dictionary.
     */
    currentWalletIds: CurrentWalletIds;
    get currentWalletIdsArray(): [string, WalletType][];
    get currentWalletIdsUnique(): string[];
    /**
     * Wallets associated with the `ParaCore` instance. Retrieve a particular wallet using `para.wallets[walletId]`.
     */
    wallets: Record<string, Wallet>;
    /**
     * The addresses of the currently active external wallets.
     */
    currentExternalWalletAddresses?: string[];
    /**
     * Wallets associated with the `ParaCore` instance.
     */
    externalWallets: Record<string, Wallet>;
    /**
     * A map of pre-generated wallet identifiers that can be claimed in the current instance.
     */
    get pregenIds(): PregenIds;
    /**
     * Whether the instance has multiple wallets connected.
     */
    get isMultiWallet(): boolean;
    /**
     * Base theme for the emails sent from this Para instance.
     * @default - dark
     * @deprecated configure theming through the developer portal
     */
    emailTheme?: EmailTheme;
    /**
     * Hex color to use as the primary color in the emails.
     * @default - #FE452B
     * @deprecated configure theming through the developer portal
     */
    emailPrimaryColor?: string;
    /**
     * Linkedin URL to link to in the emails. Should be a secure URL string starting with https://www.linkedin.com/company/.
     * @deprecated configure this through the developer portal
     */
    linkedinUrl?: string;
    /**
     * Github URL to link to in the emails. Should be a secure URL string starting with https://github.com/.
     * @deprecated configure this through the developer portal
     */
    githubUrl?: string;
    /**
     * X (Twitter) URL to link to in the emails. Should be a secure URL string starting with https://twitter.com/.
     * @deprecated configure this through the developer portal
     */
    xUrl?: string;
    /**
     * Support URL to link to in the emails. This can be a secure https URL or a mailto: string. Will default to using the stored application URL is nothing is provided here.
     * @deprecated homepageUrl will be used for this, configure it through the developer portal
     */
    supportUrl?: string;
    /**
     * URL for your home landing page. Should be a secure URL string starting with https://.
     * @deprecated configure this through the developer portal
     */
    homepageUrl?: string;
    /**
     * Encryption key pair generated from loginEncryptionKey.
     */
    loginEncryptionKeyPair?: pkiType.rsa.KeyPair;
    /**
     * Hex color to use in the portal for the background color.
     * @deprecated use portalTheme instead
     */
    portalBackgroundColor?: string;
    /**
     * Hex color to use in the portal for the primary button.
     * @deprecated use portalTheme instead
     */
    portalPrimaryButtonColor?: string;
    /**
     * Hex text color to use in the portal.
     * @deprecated use portalTheme instead
     */
    portalTextColor?: string;
    /**
     * Hex color to use in the portal for the primary button text.
     * @deprecated use portalTheme instead
     */
    portalPrimaryButtonTextColor?: string;
    /**
     * Theme to use for the portal
     * @deprecated configure theming through the developer portal
     */
    portalTheme?: Theme;
    private disableProviderModal?;
    get supportedWalletTypes(): SupportedWalletTypes;
    get isWalletTypeEnabled(): Partial<Record<WalletType, boolean>>;
    private platformUtils;
    private localStorageGetItem;
    private localStorageSetItem;
    private sessionStorageGetItem;
    private sessionStorageSetItem;
    private sessionStorageRemoveItem;
    retrieveSessionCookie: () => string | undefined;
    persistSessionCookie: (cookie: string) => void;
    /**
     * Remove all local storage and prefixed session storage.
     * @param {'local' | 'session' | 'secure' | 'all'} type - Type of storage to clear. Defaults to 'all'.
     */
    clearStorage: (type?: 'local' | 'session' | 'secure' | 'all') => Promise<void>;
    private convertBigInt;
    private convertEncryptionKeyPair;
    private isPortal;
    private isParaConnect;
    private requireApiKey;
    private isWalletSupported;
    private isWalletOwned;
    private isPregenWalletUnclaimed;
    private isPregenWalletClaimable;
    private isWalletUsable;
    /**
     * Returns the formatted address for the desired wallet ID, depending on your app settings.
     * @param {string} walletId the ID of the wallet address to display.
     * @param {object} options additional options for formatting the address.
     * @param {boolean} options.truncate whether to truncate the address.
     * @param {WalletType} options.addressType the type of address to display.
     * @returns the formatted address
     */
    getDisplayAddress(walletId: string, options?: {
        truncate?: boolean;
        addressType?: WalletTypeProp | undefined;
    } | undefined): string;
    /**
     * Returns a unique hash for a wallet suitable for use as an identicon seed.
     * @param {string} walletId the ID of the wallet.
     * @param {boolean} options.addressType used to format the hash for another wallet type.
     * @returns the identicon hash string
     */
    getIdenticonHash(walletId: string, overrideType?: WalletType): string | undefined;
    getWallets(): Record<string, Wallet>;
    getAddress(walletId?: string): string | undefined;
    protected abstract getPlatformUtils(): PlatformUtils;
    private constructPortalUrl;
    /**
     * Constructs a new `ParaCore` instance.
     * @param env - `Environment` to use.
     * @param apiKey - API key to use.
     * @param opts - Additional constructor options; see `ConstructorOpts`.
     * @returns - A new ParaCore instance.
     */
    constructor(env: Environment, apiKey?: string, opts?: ConstructorOpts);
    touchSession(regenerate?: boolean): Promise<Awaited<ReturnType<Client['touchSession']>>>;
    private setSupportedWalletTypes;
    private getVerificationEmailProps;
    private getBackupKitEmailProps;
    /**
     * Initialize storage relating to a `ParaCore` instance.
     *
     * Init only needs to be called for storage that is async.
     */
    init(): Promise<void>;
    /**
     * Sets the email associated with the `ParaCore` instance.
     * @param email - Email to set.
     */
    setEmail(email: string): Promise<void>;
    /**
     * Sets the Telegram user ID associated with the `ParaCore` instance.
     * @param telegramUserId - Telegram user ID to set.
     */
    setTelegramUserId(telegramUserId: string): Promise<void>;
    /**
     * Sets the phone number associated with the `ParaCore` instance.
     * @param phone - Phone number to set.
     * @param countryCode - Country Code to set.
     */
    setPhoneNumber(phone: string, countryCode: CountryCallingCode): Promise<void>;
    /**
     * Sets the farcaster username associated with the `ParaCore` instance.
     * @param farcasterUsername - Farcaster Username to set.
     */
    setFarcasterUsername(farcasterUsername: string): Promise<void>;
    /**
     * Sets the external wallet address and type associated with the `ParaCore` instance.
     * @param externalAddress - External wallet address to set.
     * @param externalType - Type of external wallet to set.
     */
    setExternalWallet({ address, type, provider, addressBech32 }: ExternalWalletInfo): Promise<void>;
    /**
     * Sets the user id associated with the `ParaCore` instance.
     * @param userId - User id to set.
     */
    setUserId(userId: string): Promise<void>;
    /**
     * Sets the wallets associated with the `ParaCore` instance.
     * @param wallets - Wallets to set.
     */
    setWallets(wallets: Record<string, Wallet>): Promise<void>;
    /**
     * Sets the external wallets associated with the `ParaCore` instance.
     * @param externalWallets - External wallets to set.
     */
    setExternalWallets(externalWallets: Record<string, Wallet>): Promise<void>;
    setCurrentExternalWalletAddresses(currentExternalWalletAddresses: string[]): Promise<void>;
    /**
     * Sets the login encryption key pair associated with the `ParaCore` instance.
     * @param keyPair - Encryption key pair generated from loginEncryptionKey.
     */
    protected setLoginEncryptionKeyPair(keyPair?: pkiType.rsa.KeyPair): Promise<void>;
    private deleteLoginEncryptionKeyPair;
    /**
     * Gets the userId associated with the `ParaCore` instance.
     * @returns - userId associated with the `ParaCore` instance.
     */
    getUserId(): string | undefined;
    /**
     * Gets the email associated with the `ParaCore` instance.
     * @returns - email associated with the `ParaCore` instance.
     */
    getEmail(): string | undefined;
    /**
     * Gets the phone object associated with the `ParaCore` instance.
     * @returns - phone object with phone number and country code associated with the `ParaCore` instance.
     */
    getPhone(): {
        phone?: string;
        countryCode?: string;
    };
    /**
     * Gets the formatted phone number associated with the `ParaCore` instance.
     * @returns - formatted phone number associated with the `ParaCore` instance.
     */
    getPhoneNumber(): string | undefined;
    /**
     * Gets the farcaster username associated with the `ParaCore` instance.
     * @returns - farcaster username associated with the `ParaCore` instance.
     */
    getFarcasterUsername(): string | undefined;
    setCurrentWalletIds(currentWalletIds: CurrentWalletIds, { needsWallet, sessionLookupId, newDeviceSessionLookupId, }?: {
        needsWallet?: boolean;
        sessionLookupId?: string;
        newDeviceSessionLookupId?: string;
    }): Promise<void>;
    /**
     * The prefix for the instance's managed Cosmos wallets. Defaults to `'cosmos'`.
     */
    cosmosPrefix?: string;
    /**
     * Validates that a wallet ID is present on the instance, usable, and matches the desired filters.
     * If no ID is passed, this will instead return the first valid, usable wallet ID that matches the filters.
     * @param {string} [walletId] the wallet ID to validate.
     * @param {WalletFilters} [filter={}] a `WalletFilters` object specifying allowed types, schemes, and whether to forbid unclaimed pregen wallets.
     * @returns {string} the wallet ID originally passed, or the one found.
     */
    findWalletId(walletId?: string, filter?: WalletFilters): string;
    /**
     * Retrieves a wallet with the given address, if present.
     * If no ID is passed, this will instead return the first valid, usable wallet ID that matches the filters.
     * @param {string} [walletId] the wallet ID to validate.
     * @param {WalletFilters} [filter={}] a `WalletFilters` object specifying allowed types, schemes, and whether to forbid unclaimed pregen wallets.
     * @returns {string} the wallet ID originally passed, or the one found.
     */
    findWalletByAddress(address: string, filter?: WalletFilters | undefined): any;
    findWallet(idOrAddress?: string, overrideType?: WalletTypeProp, filter?: WalletFilters): Omit<Wallet, 'signer'> | undefined;
    get availableWallets(): Pick<Wallet, 'id' | 'type' | 'name' | 'address' | 'isExternal'>[];
    /**
     * Retrieves all usable wallets with the provided type (`'EVM' | 'COSMOS' | 'SOLANA'`)
     * @param {string} type the wallet type to filter by.
     * @returns {Wallet[]} an array of matching wallets.
     */
    getWalletsByType(type: WalletTypeProp): Wallet[];
    private assertIsValidWalletId;
    private assertIsValidWalletType;
    private getMissingTypes;
    private getTypesToCreate;
    private getPartnerURL;
    /**
     * URL of the portal, which can be associated with a partner id
     * @param partnerId: string - id of the partner to get the portal URL for
     * @returns - portal URL
     */
    protected getPortalURL(partnerId?: string): Promise<string>;
    private getWebAuthURLForCreate;
    private getPasswordURLForCreate;
    private getShortUrl;
    shortenLoginLink(link: string): Promise<string>;
    /**
     * Generates a URL for registering a new WebAuth passkey.
     * @param {GetWebAuthUrlForLoginParams} opts the options object
     * @returns - the URL for creating a new passkey
     */
    getWebAuthURLForLogin(opts: GetWebAuthUrlForLoginParams): Promise<string>;
    /**
     * Generates a URL for registering a new user password.
     * @param {GetWebAuthUrlForLoginParams} opts the options object
     * @returns - the URL for creating a new password
     */
    getPasswordURLForLogin(opts: GetWebAuthUrlForLoginParams): Promise<string>;
    /**
     * Generates a URL for registering a new WebAuth passkey for a phone number.
     * @param {Omit<GetWebAuthUrlForLoginParams, 'authType'>} opts the options object
     * @returns - web auth url
     */
    getWebAuthURLForLoginForPhone(opts: Omit<GetWebAuthUrlForLoginParams, 'authType'>): Promise<string>;
    /**
     * Gets the private key for the given wallet.
     * @param {string } [walletId] id of the wallet to get the private key for. Will default to the first wallet if not provided.
     * @returns - the private key string.
     */
    protected getPrivateKey(walletId?: string): Promise<string>;
    /**
     * Fetches the wallets associated with the user.
     * @returns {WalletEntity[]} wallets that were fetched.
     */
    fetchWallets(): Promise<WalletEntity[]>;
    private populateWalletAddresses;
    private populatePregenWalletAddresses;
    /**
     * Checks if a user exists for an email address.
     * @param {Object} opts the options object
     * @param {string} opts.email the email to check.
     * @returns true if user exists, false otherwise.
     */
    checkIfUserExists({ email }: {
        email: string;
    }): Promise<boolean>;
    /**
     * Checks if a user exists for a phone number.
     * @param {Object} opts the options object
     * @param {string} opts.phone - phone number to check.
     * @param {string} opts.countryCode - the country code.
     * @returns true if user exists, false otherwise.
     */
    checkIfUserExistsByPhone({ phone, countryCode }: {
        phone: string;
        countryCode: string;
    }): Promise<boolean>;
    /**
     * Creates a new user.
     * @param {Object} opts the options object
     * @param {string} opts.email the email to use.
     */
    createUser({ email }: Auth<'email'>): Promise<void>;
    /**
     * Creates a new user with a phone number.
     * @param {Object} opts the options object
     * @param {string} opts.phone - the phone number to use for creating the user.
     * @param {string} opts.countryCode - the country code to use for creating the user.
     */
    createUserByPhone({ phone, countryCode }: Auth<'phone'>): Promise<void>;
    /**
     * Logs in or creates a new user using an external wallet address.
     * @param {Object} opts the options object
     * @param {string} opts.address the external wallet address to use for identification.
     * @param {WalletType} opts.type type of external wallet to use for identification.
     * @param {string} opts.provider the name of the provider for the external wallet.
     */
    externalWalletLogin(wallet: ExternalWalletInfo): Promise<void>;
    /**
     * Returns whether or not the user is connected with an external wallet.
     */
    protected isUsingExternalWallet(): boolean;
    /**
     * Passes the email code obtained from the user for verification.
     * @param {Object} opts the options object
     * @param {string} verificationCode the six-digit code to check
     * @returns {string} the web auth url for creating a new credential
     */
    verifyEmail({ verificationCode }: {
        verificationCode: string;
    }): Promise<string>;
    /**
     * Passes the phone code obtained from the user for verification.
     * @param {Object} opts the options object
     * @param {string} verificationCode the six-digit code to check
     * @returns {string} the web auth url for creating a new credential
     */
    verifyPhone({ verificationCode }: {
        verificationCode: string;
    }): Promise<string>;
    /**
     * Validates the response received from an attempted Telegram login for authenticity, then
     * creates or retrieves the corresponding Para user and prepares the Para instance to sign in with that user.
     * @param authResponse - the response JSON object received from the Telegram widget.
     * @returns `{ isValid: boolean; telegramUserId?: string; userId?: string; isNewUser?: boolean; supportedAuthMethods?: AuthMethod[]; biometricHints?: BiometricLocationHint[] }`
     */
    verifyTelegram(authObject: TelegramAuthResponse): Promise<VerifyTelegramRes>;
    /**
     * Performs 2FA verification.
     * @param {Object} opts the options object
     * @param {string} opts.email the email to use for performing a 2FA verification.
     * @param {string} opts.verificationCode the verification code to received via 2FA.
     * @returns {Object} `{ address, initiatedAt, status, userId, walletId }`
     */
    verify2FA({ email, verificationCode }: {
        email: string;
        verificationCode: string;
    }): Promise<{
        initiatedAt?: Date;
        status?: RecoveryStatus;
        userId: string;
        wallets: Pick<Wallet, 'address' | 'id'>[];
    }>;
    /**
     * Performs 2FA verification.
     * @param {Object} opts the options object
     * @param {string} opts.phone the phone number
     * @param {string} opts.countryCode - the country code
     * @param {string} opts.verificationCode - verification code to received via 2FA.
     * @returns {Object} `{ address, initiatedAt, status, userId, walletId }`
     */
    verify2FAForPhone({ phone, countryCode, verificationCode, }: {
        phone: string;
        countryCode: string;
        verificationCode: string;
    }): Promise<{
        initiatedAt?: Date;
        status?: RecoveryStatus;
        userId: string;
        wallets: Pick<Wallet, 'address' | 'id'>[];
    }>;
    /**
     * Sets up two-factor authentication for the current user.
     * @returns {string} uri - uri to use for setting up 2FA
     * */
    setup2FA(): Promise<{
        uri?: string;
    }>;
    /**
     * Enables 2FA.
     * @param {Object} opts the options object
     * @param {string} opts.verificationCode - the verification code received via 2FA.
     */
    enable2FA({ verificationCode }: {
        verificationCode: string;
    }): Promise<void>;
    /**
     * Determines if 2FA has been set up.
     * @returns {Object} `{ isSetup: boolean }` - true if 2FA is setup, false otherwise
     */
    check2FAStatus(): Promise<{
        isSetup: boolean;
    }>;
    /**
     * Resend a verification email for the current user.
     */
    resendVerificationCode(): Promise<void>;
    /**
     * Resend a verification SMS for the current user.
     */
    resendVerificationCodeByPhone(): Promise<void>;
    /**
     * Returns a URL for setting up a new WebAuth passkey.
     * @param {Object} opts the options object
     * @param {string} opts.authType - the auth type to use
     * @param {boolean} opts.isForNewDevice whether the passkey is for a new device of an existing user
     * @returns {string} the URL
     */
    getSetUpBiometricsURL({ authType, isForNewDevice, }?: Pick<PortalUrlOptions, 'authType' | 'isForNewDevice'>): Promise<string>;
    /**
     * Returns a URL for setting up a new WebAuth passkey for a phone number.
     * @param {Object} opts the options object
     * @param {boolean} opts.isForNewDevice whether the passkey is for a new device of an existing user
     * @returns {string} the URL
     */
    getSetUpBiometricsURLForPhone({ isForNewDevice, }?: Pick<PortalUrlOptions, 'isForNewDevice'>): Promise<string>;
    /**
     * Returns a URL for setting up a new password.
     * @param {Object} opts the options object
     * @param {string} opts.authType - the auth type to use
     * @param {boolean} opts.isForNewDevice whether the passkey is for a new device of an existing user
     * @param {Theme} [opts.theme] the portal theme to use in place of the partner's default
     * @returns {string} the URL
     */
    getSetupPasswordURL({ authType, isForNewDevice, theme, }?: Pick<PortalUrlOptions, 'authType' | 'isForNewDevice' | 'theme'>): Promise<string>;
    /**
     * Checks if the current session is active.
     * @returns `true` if active, `false` otherwise
     */
    isSessionActive(): Promise<boolean>;
    /**
     * Checks if a session is active and a wallet exists.
     * @returns `true` if active, `false` otherwise
     **/
    isFullyLoggedIn(): Promise<boolean>;
    protected supportedAuthMethods(auth: Auth): Promise<Set<AuthMethod>>;
    /**
     * Get hints associated with the users stored biometrics.
     * @returns Array containing useragents and AAGuids for stored biometrics
     */
    protected getUserBiometricLocationHints(): Promise<BiometricLocationHint[]>;
    private setAuth;
    /**
     * Initiates a login.
     * @param {Object} opts the options object
     * @param {String} opts.email - the email to login with
     * @param {boolean} opts.useShortURL - whether to shorten the link
     * @returns - the WebAuth URL for logging in
     **/
    initiateUserLogin({ useShortUrl, ...auth }: Auth & {
        useShortUrl?: boolean;
    }): Promise<string>;
    /**
     * Initiates a login.
     * @param email - the email to login with
     * @returns - a set of supported auth methods for the user
     **/
    initiateUserLoginV2(auth: Auth): Promise<Set<AuthMethod>>;
    /**
     * Initiates a login.
     * @param opts the options object
     * @param opts.phone the phone number
     * @param opts.countryCode the country code
     * @param opts.useShortURL - whether to shorten the link
     * @returns - the WebAuth URL for logging in
     **/
    initiateUserLoginForPhone({ useShortUrl, ...auth }: Auth<'phone'> & {
        useShortUrl?: boolean;
    }): Promise<string>;
    /**
     * Waits for the session to be active.
     **/
    waitForAccountCreation(): Promise<boolean>;
    waitForPasskeyAndCreateWallet(): Promise<AccountSetupResponse>;
    /**
     * Initiates a Farcaster login attempt and return the URI for the user to connect.
     * You can create a QR code with this URI that works with Farcaster's mobile app.
     * @return {string} the Farcaster connect URI
     */
    getFarcasterConnectURL(): Promise<string>;
    /**
     * Awaits the response from a user's attempt to log in with Farcaster.
     * If successful, this returns the user's Farcaster username and profile picture and indicates whether the user already exists.
     * @return {Object} `{userExists: boolean; username: string; pfpUrl?: string | null }` - the user's information and whether the user already exists.
     */
    waitForFarcasterStatus(): Promise<{
        userExists: boolean;
        username: string;
        pfpUrl?: string | null;
    }>;
    /**
     * Generates a URL for the user to log in with OAuth using a desire method.
     *
     * @param {Object} opts the options object
     * @param {OAuthMethod} opts.method the third-party service to use for OAuth.
     * @returns {string} the URL for the user to log in with OAuth.
     */
    getOAuthURL({ method }: {
        method: OAuthMethod;
    }): Promise<string>;
    /**
     * Awaits the response from a user's attempt to log in with OAuth.
     * If successful, this returns the user's email address and indicates whether the user already exists.
     *
     * @param {Object} opts the options object.
     * @param {Window} [opts.popupWindow] the popup window being used for login.
     * @return {Object} `{ email?: string; isError?: boolean; userExists: boolean; }` the result data
     */
    waitForOAuth({ popupWindow }?: {
        popupWindow?: Window;
    }): Promise<{
        email?: string;
        isError?: boolean;
        userExists: boolean;
    }>;
    /**
     * Waits for the session to be active and sets up the user.
     *
     * @param {Object} opts the options object
     * @param {Window} [opts.popupWindow] the popup window being used for login.
     * @param {boolean} [opts.skipSessionRefresh] whether to skip refreshing the session.
     * @returns {Object} `{ isComplete: boolean; isError: boolean; needsWallet: boolean; partnerId: string; }` the result data
     **/
    waitForLoginAndSetup({ popupWindow, skipSessionRefresh, }?: {
        popupWindow?: Window;
        skipSessionRefresh?: boolean;
    }): Promise<LoginResponse>;
    /**
     * Updates the session with the user management server, possibly
     * opening a popup to refresh the session.
     *
     * @param {Object} opts the options object.
     * @param {boolean} [shouldOpenPopup] - if `true`, the running device will open a popup to reauthenticate the user.
     * @returns a URL for the user to reauthenticate.
     **/
    refreshSession({ shouldOpenPopup }?: {
        shouldOpenPopup?: boolean;
    }): Promise<string>;
    /**
     * Call this method after login to ensure that the user ID is set
     * internally.
     **/
    protected userSetupAfterLogin(): Promise<{
        data: {
            partnerId?: string;
            needsWallet?: boolean;
            sessionLookupId: string;
        };
    }>;
    /**
     * Get transmission shares associated with session.
     * @param {Object} opts the options object.
     * @param {boolean} opts.isForNewDevice - true if this device is registering.
     * @returns - transmission keyshares.
     **/
    protected getTransmissionKeyShares({ isForNewDevice }?: {
        isForNewDevice?: boolean;
    }): Promise<any>;
    /**
     * Call this method after login to perform setup.
     * @param {Object} opts the options object.
     * @param {any[]} opts.temporaryShares optional temporary shares to use for decryption.
     * @param {boolean} [opts.skipSessionRefresh] - whether or not to skip refreshing the session.
     **/
    setupAfterLogin({ temporaryShares, skipSessionRefresh, }?: {
        temporaryShares?: any[];
        skipSessionRefresh?: boolean;
    }): Promise<void>;
    /**
     * Distributes a new wallet recovery share.
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the wallet to distribute the recovery share for.
     * @param {string} opts.userShare optional user share generate the recovery share from. Defaults to the signer from the passed in walletId
     * @param {boolean} opts.skipBiometricShareCreation whether or not to skip biometric share creation. Used when regenerating recovery shares.
     * @param {boolean} opts.forceRefreshRecovery whether or not to force recovery secret regeneration. Used when regenerating recovery shares.
     * @returns {string} the recovery share.
     **/
    distributeNewWalletShare({ walletId, userShare, skipBiometricShareCreation, forceRefresh, }: {
        walletId: string;
        userShare?: string;
        skipBiometricShareCreation?: boolean;
        forceRefresh?: boolean;
    }): Promise<string>;
    private waitForWalletAddress;
    /**
     * Waits for a pregen wallet address to be created.
     *
     * @param pregenIdentifier - the identifier of the user the pregen wallet is associated with.
     * @param walletId - the wallet id
     * @param pregenIdentifierType - the identifier type of the user the pregen wallet is associated with.
     * @returns - recovery share.
     **/
    private waitForPregenWalletAddress;
    /**
     * Creates several new wallets with the desired types. If no types are provided, this method
     * will create one for each of the non-optional types specified in the instance's `supportedWalletTypes`
     * object that are not already present. This is automatically called upon account creation to ensure that
     * the user has a wallet of each required type.
     *
     * @deprecated alias for `createWalletPerType`
     **/
    createWalletPerMissingType: ({ skipDistribute, types, }?: {
        skipDistribute?: boolean;
        types?: WalletType[];
    }) => Promise<{
        wallets: Wallet[];
        walletIds: CurrentWalletIds;
        recoverySecret?: string;
    }>;
    /**
     * Creates several new wallets with the desired types. If no types are provided, this method
     * will create one for each of the non-optional types specified in the instance's `supportedWalletTypes`
     * object that are not already present. This is automatically called upon account creation to ensure that
     * the user has a wallet of each required type.
     *
     * @param {Object} [opts] the options object.
     * @param {boolean} [opts.skipDistribute] if `true`, the wallets' recovery share will not be distributed.
     * @param {WalletType[]} [opts.types] the types of wallets to create.
     * @returns {Object} the wallets created, their ids, and the recovery secret.
     **/
    createWalletPerType({ skipDistribute, types, }?: {
        skipDistribute?: boolean;
        types?: WalletType[];
    }): Promise<{
        wallets: Wallet[];
        walletIds: CurrentWalletIds;
        recoverySecret?: string;
    }>;
    /**
     * Refresh the current user share for a wallet.
     *
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the wallet id to refresh.
     * @param {string} opts.share the current user share.
     * @param {string} [opts.oldPartnerId] the current partner id.
     * @param {string} [opts.newPartnerId] the new partner id to set, if any.
     * @param {string} [opts.keyShareProtocolId]
     * @param {boolean} [opts.redistributeBackupEncryptedShares] whether or not to redistribute backup encrypted shares.
     * @returns {Object} the new user share and recovery secret.
     **/
    refreshShare({ walletId, share, oldPartnerId, newPartnerId, keyShareProtocolId, redistributeBackupEncryptedShares, }: {
        walletId: string;
        share: string;
        oldPartnerId?: string;
        newPartnerId?: string;
        keyShareProtocolId?: string;
        redistributeBackupEncryptedShares?: boolean;
        emailProps?: BackupKitEmailProps;
    }): Promise<{
        signer: string;
        recoverySecret?: string;
        protocolId: string;
    }>;
    /**
     * Creates a new wallet.
     * @param {Object} opts the options object.
     * @param {WalletType} opts.type the type of wallet to create.
     * @param {boolean} opts.skipDistribute - if true, recovery share will not be distributed.
     * @returns {[Wallet, string | null]} `[wallet, recoveryShare]` - the wallet object and the new recovery share.
     **/
    createWallet({ type: _type, skipDistribute, }?: {
        type?: WalletType;
        skipDistribute?: boolean;
    }): Promise<[Wallet, string | null]>;
    /**
     * Creates a new pregenerated wallet.
     *
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier the identifier associated with the new wallet.
     * @param {TPregenIdentifierType} [opts.pregenIdentifierType] the identifier type. Defaults to `EMAIL`.
     * @param {WalletType} [opts.type] the type of wallet to create. Defaults to the first non-optional type in the instance's `supportedWalletTypes` array.
     * @returns {Wallet} the created wallet.
     **/
    createPregenWallet(opts: {
        type: WalletType;
        pregenIdentifier: string;
        pregenIdentifierType: TPregenIdentifierType;
    }): Promise<Wallet>;
    /**
     * Creates new pregenerated wallets for each desired type.
     * If no types are provided, this method will create one for each of the non-optional types
     * specified in the instance's `supportedWalletTypes` array that are not already present.
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier the identifier to associate each wallet with.
     * @param {TPregenIdentifierType} opts.pregenIdentifierType - either `'EMAIL'` or `'PHONE'`.
     * @param {WalletType[]} [opts.types] the wallet types to create. Defaults to any types the instance supports that are not already present.
     * @returns {Wallet[]} an array containing the created wallets.
     **/
    createPregenWalletPerType({ types, pregenIdentifier, pregenIdentifierType, }: {
        pregenIdentifier: string;
        pregenIdentifierType: TPregenIdentifierType;
        types?: WalletType[];
    }): Promise<Wallet[]>;
    /**
     * Claims a pregenerated wallet.
     *
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier string the identifier of the user claiming the wallet
     * @param {TPregenIdentifierType} opts.pregenIdentifierType type of the identifier of the user claiming the wallet
     * @returns {[Wallet, string | null]} `[wallet, recoveryShare]` - the wallet object and the new recovery share.
     **/
    claimPregenWallets({ pregenIdentifier, pregenIdentifierType, }?: {
        pregenIdentifier?: string;
        pregenIdentifierType?: TPregenIdentifierType;
    }): Promise<string | undefined>;
    /**
     * Updates the identifier for a pregen wallet.
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the pregen wallet ID
     * @param {string} opts.newPregenIdentifier the new identtifier
     * @param {TPregenIdentifierType} opts.newPregenIdentifierType: the new identifier type
     **/
    updatePregenWalletIdentifier({ walletId, newPregenIdentifier, newPregenIdentifierType, }: {
        walletId: string;
        newPregenIdentifier: string;
        newPregenIdentifierType: TPregenIdentifierType;
    }): Promise<void>;
    /**
     * Checks if a pregen Wallet exists for the given identifier with the current partner.
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier string the identifier of the user claiming the wallet
     * @param {TPregenIdentifierType} opts.pregenIdentifierType type of the string of the identifier of the user claiming the wallet
     * @returns {boolean} whether the pregen wallet exists
     **/
    hasPregenWallet({ pregenIdentifier, pregenIdentifierType, }: {
        pregenIdentifier: string;
        pregenIdentifierType: TPregenIdentifierType;
    }): Promise<boolean>;
    /**
     * Get pregen wallets for the given identifier.
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier - the identifier of the user claiming the wallet
     * @param {TPregenIdentifierType} opts.pregenIdentifierType - type of the identifier of the user claiming the wallet
     * @returns {Promise<WalletEntity[]>} the array of found wallets
     **/
    getPregenWallets({ pregenIdentifier, pregenIdentifierType, }?: {
        pregenIdentifier?: string;
        pregenIdentifierType?: TPregenIdentifierType;
    }): Promise<WalletEntity[]>;
    private encodeWalletBase64;
    /**
     * Encodes the current wallets encoded in Base 64.
     * @returns {string} the encoded wallet string
     **/
    getUserShare(): string | null;
    /**
     * Sets the current wallets from a Base 64 string.
     * @param {string} base64Wallet the encoded wallet string
     **/
    setUserShare(base64Wallets: string | null): Promise<void>;
    private getTransactionReviewUrl;
    private getOnRampTransactionUrl;
    /**
     * Signs a message using one of the current wallets.
     *
     * If you want to sign the keccak256 hash of a message, hash the
     * message first and then pass in the base64 encoded hash.
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the id of the wallet to sign with.
     * @param {string} opts.messageBase64 the base64 encoding of exact message that should be signed
     * @param {number} [opts.timeout] optional timeout in milliseconds. If not present, defaults to 30 seconds.
     * @param {string} [opts.cosmosSignDocBase64] the Cosmos `SignDoc` in base64, if applicable
     **/
    signMessage({ walletId, messageBase64, timeoutMs, cosmosSignDocBase64, }: {
        walletId: string;
        messageBase64: string;
        timeoutMs?: number;
        cosmosSignDocBase64?: string;
    }): Promise<FullSignatureRes>;
    private signMessageInner;
    /**
     * Signs a transaction.
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the id of the wallet to sign with.
     * @param {string} opts.rlpEncodedTxBase64 the transaction to sign, in RLP base64 encoding
     * @param {string} [opts.chainId] the EVM chain id of the chain the transaction is being sent on, if applicable
     * @param {number} [opts.timeoutMs] the amount of time to wait for the user to sign the transaction, in milliseconds
     **/
    signTransaction({ walletId, rlpEncodedTxBase64, chainId, timeoutMs, }: {
        walletId: string;
        rlpEncodedTxBase64: string;
        chainId: string;
        timeoutMs?: number;
    }): Promise<FullSignatureRes>;
    /**
     * @deprecated
     * Sends a transaction.
     * @param walletId - id of the wallet to send the transaction from.
     * @param rlpEncodedTxBase64 - rlp encoded tx as base64 string
     * @param chainId - chain id of the chain the transaction is being sent on.
     **/
    sendTransaction({ walletId, rlpEncodedTxBase64, chainId, }: {
        walletId: string;
        rlpEncodedTxBase64: string;
        chainId: string;
    }): Promise<FullSignatureRes>;
    protected isProviderModalDisabled(): boolean;
    /**
     * Starts a on-ramp or off-ramp transaction and returns the Para Portal link for the user to finalize and complete it.
     * @param {Object} opts the options object
     * @param {OnRampPurchaseCreateParams} opts.params the transaction settings.
     * @param {boolean} opts.shouldOpenPopup if `true`, a popup window with the link will be opened.
     * @param {string} opts.walletId the wallet ID to use for the transaction, where funds will be sent or withdrawn.
     * @param {string} opts.externalWalletAddress the external wallet address to send funds to or withdraw funds from, if using an external wallet.
     **/
    initiateOnRampTransaction(options: WalletParams & {
        params: OnRampPurchaseCreateParams;
        shouldOpenPopup?: boolean;
    }): Promise<{
        onRampPurchase: OnRampPurchase;
        portalUrl: string;
    }>;
    /**
     * Returns `true` if session was successfully kept alive, `false` otherwise.
     **/
    keepSessionAlive(): Promise<boolean>;
    /**
     * Serialize the current session for import by another Para instance.
     * @returns {string} the serialized session
     */
    exportSession(): string;
    /**
     * Imports a session serialized by another Para instance.
     * @param {string} serializedInstanceBase64 the serialized session
     */
    importSession(serializedInstanceBase64: string): Promise<void>;
    protected exitAccountCreation(): void;
    protected exitLogin(): void;
    protected exitFarcaster(): void;
    protected exitOAuth(): void;
    protected exitLoops(): void;
    /**
     * Logs the user out.
     * @param {Object} opts the options object.
     * @param {boolean} opts.clearPregenWallets if `true`, will remove all pregen wallets from storage
     **/
    logout({ clearPregenWallets }?: {
        clearPregenWallets?: boolean;
    }): Promise<void>;
    protected getSupportedCreateAuthMethods(): Promise<Set<AuthMethod>>;
    /**
     * Converts to a string, removing sensitive data when logging this class.
     *
     * Doesn't work for all types of logging.
     **/
    toString(): string;
}
