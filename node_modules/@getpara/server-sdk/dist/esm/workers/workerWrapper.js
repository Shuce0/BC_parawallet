var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Worker } from 'worker_threads';
import { getPortalBaseURL } from '@getpara/core-sdk';
const CLEAR_WORKER_TIMEOUT_MS = 1000 * 90;
let worker;
const resFunctionMap = {};
function removeWorkId(workId, skipClearTimeout) {
    const { timeoutId } = resFunctionMap[workId];
    delete resFunctionMap[workId];
    if (skipClearTimeout) {
        return;
    }
    clearTimeout(timeoutId);
}
export function setupWorker(ctx, resFunction, workId) {
    return __awaiter(this, void 0, void 0, function* () {
        const timeoutId = setTimeout(() => {
            removeWorkId(workId, true);
        }, CLEAR_WORKER_TIMEOUT_MS);
        resFunctionMap[workId] = {
            fn: resFunction,
            timeoutId,
        };
        if (!worker || !worker.threadId) {
            const workerRes = yield fetch(`${getPortalBaseURL(ctx)}/static/js/mpcWorkerServer-bundle.js`);
            worker = new Worker(yield workerRes.text(), { eval: true });
            const onmessage = (message) => __awaiter(this, void 0, void 0, function* () {
                const { workId: messageWorkId } = message;
                delete message.workId;
                yield resFunctionMap[messageWorkId].fn(message);
                removeWorkId(messageWorkId);
            });
            worker.on('message', onmessage);
            worker.on('error', err => {
                throw err;
            });
            worker.on('exit', code => {
                console.error(`worker stopped with exit code ${code}`);
            });
        }
        return worker;
    });
}
