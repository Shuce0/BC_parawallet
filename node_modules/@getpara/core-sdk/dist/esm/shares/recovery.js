var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { EncryptorType, KeyShareType } from '@getpara/user-management-client';
import { KeyContainer } from './KeyContainer.js';
export function sendRecoveryForShare({ ctx, userId, walletId, otherEncryptedShares = [], userSigner, ignoreRedistributingBackupEncryptedShare = false, emailProps = {}, forceRefresh = false, }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (ignoreRedistributingBackupEncryptedShare) {
            yield ctx.client.uploadUserKeyShares(userId, otherEncryptedShares.map(share => (Object.assign({ walletId }, share))));
            return '';
        }
        let userBackupKeyShareOptsArr;
        let recoveryPrivateKeyContainer;
        const { recoveryPublicKeys } = yield ctx.client.getRecoveryPublicKeys(userId);
        if (forceRefresh || !(recoveryPublicKeys === null || recoveryPublicKeys === void 0 ? void 0 : recoveryPublicKeys.length)) {
            recoveryPrivateKeyContainer = new KeyContainer(walletId, '', '');
            const { recoveryPublicKeys } = yield ctx.client.persistRecoveryPublicKeys(userId, [
                recoveryPrivateKeyContainer.getPublicEncryptionKeyHex(),
            ]);
            const encryptedUserBackup = recoveryPrivateKeyContainer.encryptForSelf(userSigner);
            userBackupKeyShareOptsArr = [
                {
                    walletId,
                    encryptedShare: encryptedUserBackup,
                    type: KeyShareType.USER,
                    encryptor: EncryptorType.RECOVERY,
                    recoveryPublicKeyId: recoveryPublicKeys[0].id,
                },
            ];
        }
        else {
            userBackupKeyShareOptsArr = recoveryPublicKeys.map(recoveryPublicKey => {
                const { id: recoveryPublicKeyId, publicKey } = recoveryPublicKey;
                const encryptedUserBackup = KeyContainer.encryptWithPublicKey(Buffer.from(publicKey, 'hex'), userSigner);
                return {
                    walletId,
                    encryptedShare: encryptedUserBackup,
                    type: KeyShareType.USER,
                    encryptor: EncryptorType.RECOVERY,
                    recoveryPublicKeyId,
                };
            });
        }
        yield ctx.client.uploadUserKeyShares(userId, [
            ...otherEncryptedShares.map(share => (Object.assign({ walletId }, share))),
            ...(ignoreRedistributingBackupEncryptedShare ? [] : userBackupKeyShareOptsArr),
        ]);
        yield ctx.client.distributeParaShare(Object.assign({ userId,
            walletId, useDKLS: ctx.useDKLS }, emailProps));
        return recoveryPrivateKeyContainer ? JSON.stringify(recoveryPrivateKeyContainer) : '';
    });
}
