import { toBech32 } from '@cosmjs/encoding';
import { sha256 } from '@noble/hashes/sha256';
import { ripemd160 } from '@noble/hashes/ripemd160';
import elliptic from 'elliptic';
import parsePhoneNumberFromString from 'libphonenumber-js';
const secp256k1 = new elliptic.ec('secp256k1');
export function hexStringToBase64(hexString) {
    if (hexString.substring(0, 2) === '0x') {
        hexString = hexString.substring(2);
    }
    return Buffer.from(hexString, 'hex').toString('base64');
}
export function hexToSignature(hexSig) {
    return {
        r: `0x${hexSig.slice(2, 66)}`,
        s: `0x${hexSig.slice(66, 130)}`,
        v: BigInt(hexSig.slice(130, 132)),
    };
}
export function hexToUint8Array(hex) {
    if (hex.startsWith('0x')) {
        hex = hex.slice(2);
    }
    return new Uint8Array(Buffer.from(hex, 'hex'));
}
export function hexToDecimal(hex) {
    if (hex.startsWith('0x')) {
        hex = hex.slice(2);
    }
    return `${parseInt(hex, 16)}`;
}
export function decimalToHex(decimal) {
    return `0x${parseInt(decimal).toString(16)}`;
}
function compressPubkey(pubkey) {
    switch (pubkey.length) {
        case 33:
            return pubkey;
        case 65:
            return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(true, 'array'));
        default:
            throw new Error('Invalid pubkey length');
    }
}
function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
    if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
    }
    return ripemd160(sha256(pubkeyData));
}
export function getCosmosAddress(publicKey, prefix) {
    const uncompressedPublicKey = new Uint8Array(Buffer.from(publicKey.startsWith('0x') ? publicKey.slice(2) : publicKey, 'hex'));
    const compressedPublicKey = compressPubkey(uncompressedPublicKey);
    return toBech32(prefix, rawSecp256k1PubkeyToRawAddress(compressedPublicKey));
}
export function truncateAddress(str, addressType, { prefix = addressType === 'COSMOS' ? 'cosmos' : undefined } = {}) {
    const headLength = (addressType === 'COSMOS' ? prefix.length : addressType === 'SOLANA' ? 0 : 2) + 4;
    return `${str.slice(0, headLength)}...${str.slice(-4)}`;
}
export function stringToPhoneNumber(str) {
    var _a;
    return (_a = parsePhoneNumberFromString(str)) === null || _a === void 0 ? void 0 : _a.formatInternational().replace(/[^\d+]/g, '');
}
export function normalizePhoneNumber(countryCode, number) {
    return stringToPhoneNumber(`${countryCode[0] !== '+' ? '+' : ''}${countryCode}${number}`);
}
