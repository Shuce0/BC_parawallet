"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptPrivateKeyWithPassword = exports.encryptPrivateKeyWithPassword = exports.hashPasswordWithSalt = exports.encryptWithDerivedPublicKey = exports.decryptPrivateKeyAndDecryptShare = exports.getDerivedPrivateKeyAndDecrypt = exports.decryptWithPrivateKey = exports.decryptWithKeyPair = exports.symmetricKeyEncryptMessage = exports.getPublicKeyFromSignature = exports.getAsymmetricKeyPair = exports.decryptPrivateKey = exports.encryptPrivateKey = exports.decodePrivateKeyPemHex = exports.encodePrivateKeyToPemHex = exports.publicKeyHexToPem = exports.publicKeyFromHex = exports.getPublicKeyHex = exports.getSHA256HashHex = void 0;
const base64url_1 = __importDefault(require("base64url"));
const node_forge_1 = __importDefault(require("node-forge"));
const index_js_1 = require("../utils/index.js");
const rsa = node_forge_1.default.pki.rsa;
const RSA_ENCRYPTION_SCHEME = 'RSA-OAEP';
// ivs can be constant only because every key is only ever used to encrypt one message
const CONSTANT_IV = '794241bc819a125a7b78ea313decc0bc';
const CONSTANT_IV_AES = new Uint8Array([23, 66, 157, 146, 179, 158, 117, 120, 184, 73, 123, 81]);
function getSHA256HashHex(str) {
    const md = node_forge_1.default.md.sha256.create();
    md.update(str);
    return md.digest().toHex();
}
exports.getSHA256HashHex = getSHA256HashHex;
function getPublicKeyHex(keyPair) {
    const pem = node_forge_1.default.pki.publicKeyToRSAPublicKeyPem(keyPair.publicKey);
    return Buffer.from(pem, 'utf-8').toString('hex');
}
exports.getPublicKeyHex = getPublicKeyHex;
function publicKeyFromHex(publicKeyHex) {
    const pem = publicKeyHexToPem(publicKeyHex);
    return node_forge_1.default.pki.publicKeyFromPem(pem);
}
exports.publicKeyFromHex = publicKeyFromHex;
function publicKeyHexToPem(publicKeyHex) {
    return Buffer.from(publicKeyHex, 'hex').toString('utf-8');
}
exports.publicKeyHexToPem = publicKeyHexToPem;
function encodePrivateKeyToPemHex(keyPair) {
    const pem = node_forge_1.default.pki.privateKeyToPem(keyPair.privateKey);
    return Buffer.from(pem, 'utf-8').toString('hex');
}
exports.encodePrivateKeyToPemHex = encodePrivateKeyToPemHex;
function decodePrivateKeyPemHex(privateKeyPemHex) {
    const pem = Buffer.from(privateKeyPemHex, 'hex').toString('utf-8');
    return node_forge_1.default.pki.privateKeyFromPem(pem);
}
exports.decodePrivateKeyPemHex = decodePrivateKeyPemHex;
function encryptPrivateKey(keyPair, key) {
    return __awaiter(this, void 0, void 0, function* () {
        const privateKeyPemHex = encodePrivateKeyToPemHex(keyPair);
        const cryptoKey = yield window.crypto.subtle.importKey('raw', Buffer.from(key, 'base64'), {
            name: 'AES-GCM',
            length: 256,
        }, true, ['encrypt', 'decrypt']);
        const encodedPlaintext = new TextEncoder().encode(privateKeyPemHex);
        const ciphertext = yield window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: CONSTANT_IV_AES }, cryptoKey, encodedPlaintext);
        return Buffer.from(ciphertext).toString('base64');
    });
}
exports.encryptPrivateKey = encryptPrivateKey;
function decryptPrivateKey(encryptedPrivateKeyPemHex, key) {
    return __awaiter(this, void 0, void 0, function* () {
        const secretKey = yield crypto.subtle.importKey('raw', Buffer.from(key, 'base64'), {
            name: 'AES-GCM',
            length: 256,
        }, true, ['encrypt', 'decrypt']);
        const cleartext = yield crypto.subtle.decrypt({ name: 'AES-GCM', iv: CONSTANT_IV_AES }, secretKey, Buffer.from(encryptedPrivateKeyPemHex, 'base64'));
        const privateKeyPemHex = new TextDecoder().decode(cleartext);
        const privateKey = decodePrivateKeyPemHex(privateKeyPemHex);
        return privateKey;
    });
}
exports.decryptPrivateKey = decryptPrivateKey;
function getAsymmetricKeyPair(ctx, seedValue) {
    return __awaiter(this, void 0, void 0, function* () {
        const prng = node_forge_1.default.random.createInstance();
        if (seedValue) {
            prng.seedFileSync = (_n) => seedValue;
            prng.seedFile = (_n, cb) => {
                cb(null, seedValue);
            };
        }
        const options = {
            bits: 2048,
            e: 65537,
            prng,
        };
        if (!ctx.disableWorkers) {
            options.workLoad = 100;
            // only using 1 web worker as more makes the call non-deterministic
            // -1 uses optimal amount of web workers
            options.workers = seedValue ? 1 : -1;
            const workerRes = yield fetch(`${(0, index_js_1.getPortalBaseURL)(ctx)}/static/js/prime.worker.min.js`);
            const workerBlob = new Blob([yield workerRes.text()], { type: 'application/javascript' });
            options.workerScript = URL.createObjectURL(workerBlob);
        }
        return new Promise((resolve, reject) => rsa.generateKeyPair(options, (err, keypair) => {
            if (err) {
                reject(err);
            }
            resolve(keypair);
        }));
    });
}
exports.getAsymmetricKeyPair = getAsymmetricKeyPair;
function getPublicKeyFromSignature(ctx, userHandle) {
    return __awaiter(this, void 0, void 0, function* () {
        const encodedUserHandle = base64url_1.default.encode(userHandle);
        const keyPair = yield getAsymmetricKeyPair(ctx, encodedUserHandle);
        return getPublicKeyHex(keyPair);
    });
}
exports.getPublicKeyFromSignature = getPublicKeyFromSignature;
// only use for one time key encryptions as iv is constant
function symmetricKeyEncryptMessage(message) {
    const key = node_forge_1.default.random.getBytesSync(16);
    const cipher = node_forge_1.default.cipher.createCipher('AES-CBC', key);
    // iv can be constant only because every key is only ever used to encrypt one message
    cipher.start({ iv: CONSTANT_IV });
    cipher.update(node_forge_1.default.util.createBuffer(message));
    cipher.finish();
    const encryptedMessageHex = cipher.output.toHex();
    return { key, encryptedMessageHex };
}
exports.symmetricKeyEncryptMessage = symmetricKeyEncryptMessage;
function decipherEncryptedMessageHex(key, encryptedMessageHex) {
    const decipher = node_forge_1.default.cipher.createDecipher('AES-CBC', key);
    // iv can be constant only because every key is only ever used to encrypt one message
    decipher.start({ iv: CONSTANT_IV });
    decipher.update(node_forge_1.default.util.createBuffer(node_forge_1.default.util.hexToBytes(encryptedMessageHex)));
    decipher.finish();
    return decipher.output.toString();
}
// Deprecated in favor of decryptWithPrivateKey
function decryptWithKeyPair(keyPair, encryptedMessageHex, encryptedKeyHex) {
    const encryptedKey = Buffer.from(encryptedKeyHex, 'hex').toString('utf-8');
    const key = keyPair.privateKey.decrypt(encryptedKey, RSA_ENCRYPTION_SCHEME);
    return decipherEncryptedMessageHex(key, encryptedMessageHex);
}
exports.decryptWithKeyPair = decryptWithKeyPair;
function decryptWithPrivateKey(privateKey, encryptedMessageHex, encryptedKeyHex) {
    const encryptedKey = Buffer.from(encryptedKeyHex, 'hex').toString('utf-8');
    const key = privateKey.decrypt(encryptedKey, RSA_ENCRYPTION_SCHEME);
    return decipherEncryptedMessageHex(key, encryptedMessageHex);
}
exports.decryptWithPrivateKey = decryptWithPrivateKey;
function decryptWithDerivedPrivateKey(ctx, { seedValue, encryptedMessageHex, encryptedKeyHex, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const keyPair = yield getAsymmetricKeyPair(ctx, seedValue);
        return decryptWithPrivateKey(keyPair.privateKey, encryptedMessageHex, encryptedKeyHex);
    });
}
function getDerivedPrivateKeyAndDecrypt(ctx, seedValue, encryptedShares) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.all(encryptedShares.map((share) => __awaiter(this, void 0, void 0, function* () {
            return ({
                walletId: share.walletId,
                walletScheme: share.walletScheme,
                partnerId: share.partnerId,
                signer: yield decryptWithDerivedPrivateKey(ctx, {
                    seedValue,
                    encryptedMessageHex: share.encryptedShare,
                    encryptedKeyHex: share.encryptedKey,
                }),
                protocolId: share.protocolId,
            });
        })));
    });
}
exports.getDerivedPrivateKeyAndDecrypt = getDerivedPrivateKeyAndDecrypt;
function decryptPrivateKeyAndDecryptShare(encryptionKey, encryptedShares, encryptedPrivateKey) {
    return __awaiter(this, void 0, void 0, function* () {
        let privateKey;
        try {
            privateKey = yield decryptPrivateKey(encryptedPrivateKey, encryptionKey);
        }
        catch (e) { }
        try {
            privateKey = yield decryptPrivateKeyWithPassword(encryptedPrivateKey, encryptionKey);
        }
        catch (e) { }
        if (!privateKey) {
            throw new Error('Could not decrypt private key');
        }
        return encryptedShares.map(share => ({
            walletId: share.walletId,
            walletScheme: share.walletScheme,
            partnerId: share.partnerId,
            signer: decryptWithPrivateKey(privateKey, share.encryptedShare, share.encryptedKey),
            protocolId: share.protocolId,
        }));
    });
}
exports.decryptPrivateKeyAndDecryptShare = decryptPrivateKeyAndDecryptShare;
function encryptWithDerivedPublicKey(publicKeyHex, message) {
    const { key, encryptedMessageHex } = symmetricKeyEncryptMessage(message);
    const publicKeyPem = publicKeyHexToPem(publicKeyHex);
    const publicKey = node_forge_1.default.pki.publicKeyFromPem(publicKeyPem);
    const encryptedKey = publicKey.encrypt(key, RSA_ENCRYPTION_SCHEME);
    const encryptedKeyHex = Buffer.from(encryptedKey, 'utf-8').toString('hex');
    return { encryptedMessageHex, encryptedKeyHex };
}
exports.encryptWithDerivedPublicKey = encryptWithDerivedPublicKey;
function hashPasswordWithSalt(password) {
    const salt = generateSalt();
    const saltedPassword = salt + password;
    const hash = getSHA256HashHex(saltedPassword);
    return { salt, hash };
}
exports.hashPasswordWithSalt = hashPasswordWithSalt;
function generateSalt(length = 16) {
    return node_forge_1.default.util.bytesToHex(node_forge_1.default.random.getBytesSync(length));
}
function deriveCryptoKeyFromPassword(hashedPassword) {
    return __awaiter(this, void 0, void 0, function* () {
        const keyBuffer = Buffer.from(hashedPassword, 'hex');
        return yield window.crypto.subtle.importKey('raw', keyBuffer, {
            name: 'AES-GCM',
            length: 256,
        }, true, ['encrypt', 'decrypt']);
    });
}
function encryptPrivateKeyWithPassword(keyPair, hashedPassword) {
    return __awaiter(this, void 0, void 0, function* () {
        const cryptoKey = yield deriveCryptoKeyFromPassword(hashedPassword);
        const privateKeyPemHex = encodePrivateKeyToPemHex(keyPair);
        const encodedPlaintext = new TextEncoder().encode(privateKeyPemHex);
        const ciphertext = yield window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: CONSTANT_IV_AES }, cryptoKey, encodedPlaintext);
        return Buffer.from(ciphertext).toString('base64');
    });
}
exports.encryptPrivateKeyWithPassword = encryptPrivateKeyWithPassword;
function decryptPrivateKeyWithPassword(encryptedPrivateKeyPemHex, hashedPassword) {
    return __awaiter(this, void 0, void 0, function* () {
        const secretKey = yield crypto.subtle.importKey('raw', Buffer.from(hashedPassword, 'hex'), {
            name: 'AES-GCM',
            length: 256,
        }, true, ['encrypt', 'decrypt']);
        const cleartext = yield crypto.subtle.decrypt({ name: 'AES-GCM', iv: CONSTANT_IV_AES }, secretKey, Buffer.from(encryptedPrivateKeyPemHex, 'base64'));
        const privateKeyPemHex = new TextDecoder().decode(cleartext);
        const privateKey = decodePrivateKeyPemHex(privateKeyPemHex);
        return privateKey;
    });
}
exports.decryptPrivateKeyWithPassword = decryptPrivateKeyWithPassword;
