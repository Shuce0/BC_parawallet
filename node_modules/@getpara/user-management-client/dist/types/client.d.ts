import { AxiosResponse } from 'axios';
import { Auth, AuthMethod, AuthParams, BackupKitEmailProps, BiometricLocationHint, Chain, CurrentWalletIds, EncryptedKeyShare, EncryptorType, KeyShareType, Network, OnRampAsset, OnRampConfig, OnRampProvider, OnRampPurchase, OnRampPurchaseCreateParams, OnRampPurchaseUpdateParams, PasswordStatus, PregenIds, PublicKeyStatus, PublicKeyType, TelegramAuthResponse, TPregenIdentifierType, VerificationEmailProps, WalletEntity, WalletParams, WalletScheme, WalletType } from './types/index.js';
interface ConfigOpts {
    useFetchAdapter?: boolean;
}
type ClientConfig = {
    userManagementHost: string;
    version?: string;
    partnerId?: string;
    apiKey?: string;
    opts?: ConfigOpts;
    retrieveSessionCookie?: () => string | undefined;
    persistSessionCookie?: (cookie: string) => void;
};
interface createUserBody {
    email: string;
}
interface createUserBodyForPhone {
    phone: string;
    countryCode: string;
}
interface ExternalWalletLoginBody {
    externalAddress: string;
    type: 'EVM' | 'SOLANA' | 'COSMOS';
    externalWalletProvider?: string;
}
interface ExternalWalletLoginRes {
    userId: string;
}
interface createUserIdRes {
    protocolId: string;
    userId: string;
}
interface verifyBody {
    verificationCode: string;
}
interface getWebChallengeRes {
    challenge: string;
    allowedPublicKeys?: string[];
}
interface sessionPublicKeyBody {
    publicKey?: string;
    sigDerivedPublicKey?: string;
    status?: PublicKeyStatus;
    type?: PublicKeyType;
    cosePublicKey?: string;
    clientDataJSON?: string;
    aaguid?: string;
}
interface WebSignature {
    clientDataJSON: string;
    authenticatorData: string;
    signature: string;
}
interface MobileSignature {
    r: string;
    s: string;
    recoveryParam: number;
}
type verifyWebChallengeBody = {
    sessionLookupId?: string;
    signature: WebSignature;
    publicKey: string;
    newDeviceSessionLookupId?: string;
};
type verifyPasswordChallengeBody = {
    sessionLookupId?: string;
    signature: string;
    publicKey: string;
    newDeviceSessionLookupId?: string;
};
interface verifySessionChallengeBody {
    signature: MobileSignature | WebSignature;
    publicKey?: string;
}
interface GetWalletsRes {
    wallets: WalletEntity[];
}
interface PasswordEntity {
    id: string;
    userId: string;
    status: PasswordStatus;
    sigDerivedPublicKey: string;
    salt: string;
}
interface createWalletBody {
    useTwoSigners?: boolean;
    scheme: WalletScheme;
    type: WalletType;
    cosmosPrefix?: string;
}
interface updatePregenWalletBody {
    pregenIdentifier: string;
    pregenIdentifierType: TPregenIdentifierType;
}
interface createWalletRes {
    protocolId: string;
    walletId: string;
}
interface createPregenWalletBody {
    pregenIdentifier: string;
    pregenIdentifierType: TPregenIdentifierType;
    scheme?: WalletScheme;
    type: WalletType;
    cosmosPrefix?: string;
}
interface claimPreGenWalletsBody {
    userId: string;
    walletIds: string[];
}
interface signTransactionBody {
    transaction: string;
    chainId: string;
}
interface sendTransactionBody {
    transaction: string;
    chain?: Chain;
    chainId?: string;
}
interface AcceptScopesBody {
    scopeIds: string[];
    partnerId: string;
}
interface sessionPasswordBody {
    status?: PasswordStatus;
    sigDerivedPublicKey?: string;
    salt?: string;
}
type BiometricLocationHintParams = AuthParams;
export type VerifyTelegramRes = {
    isValid: true;
    userId: string;
    telegramUserId: string;
    isNewUser: boolean;
    biometricHints?: BiometricLocationHint[];
    supportedAuthMethods: AuthMethod[];
} | {
    isValid: false;
};
export declare const handleResponseSuccess: (response: AxiosResponse<any, any>) => AxiosResponse<any, any>;
export declare const handleResponseError: (error: any) => never;
declare class Client {
    private baseRequest;
    constructor({ userManagementHost, apiKey, partnerId, version, opts, retrieveSessionCookie, persistSessionCookie, }: ClientConfig);
    createUser: (body: (createUserBody | createUserBodyForPhone) & VerificationEmailProps) => Promise<createUserIdRes>;
    checkUserExists: (auth: Auth<"email" | "phone">) => Promise<any>;
    verifyTelegram: (authObject: TelegramAuthResponse) => Promise<VerifyTelegramRes>;
    externalWalletLogin: (body: ExternalWalletLoginBody) => Promise<ExternalWalletLoginRes>;
    verifyEmail: (userId: string, body: verifyBody) => Promise<any>;
    verifyPhone: (userId: string, body: verifyBody) => Promise<any>;
    addSessionPublicKey: (userId: string, body: sessionPublicKeyBody) => Promise<any>;
    getSessionPublicKeys: (userId: string) => Promise<any>;
    getBiometricLocationHints: (params: BiometricLocationHintParams) => Promise<BiometricLocationHint[]>;
    getSessionPublicKey: (userId: string, biometricId: string) => Promise<any>;
    patchSessionPublicKey: (partnerId: string, userId: string, biometricId: string, body: sessionPublicKeyBody) => Promise<any>;
    getWebChallenge: (auth?: Auth) => Promise<getWebChallengeRes>;
    touchSession: (regenerate?: boolean) => Promise<any>;
    sessionOrigin: (sessionLookupId: string) => Promise<{
        origin?: string;
    }>;
    verifyWebChallenge: (partnerId: string, body: verifyWebChallengeBody) => Promise<any>;
    getSessionChallenge: (userId: string) => Promise<any>;
    verifySessionChallenge: (userId: string, body: verifySessionChallengeBody) => Promise<any>;
    createWallet: (userId: string, body?: createWalletBody) => Promise<createWalletRes>;
    createPregenWallet: (body?: createPregenWalletBody) => Promise<createWalletRes>;
    getPregenWallets: <ReturnType = {
        wallets: WalletEntity[];
    }>(pregenIds: PregenIds, isPortal?: boolean, userId?: string) => Promise<ReturnType>;
    claimPregenWallets: <ReturnType = {
        walletIds?: string[];
    }>(body?: claimPreGenWalletsBody) => Promise<ReturnType>;
    sendTransaction: (userId: string, walletId: string, body: sendTransactionBody) => Promise<any>;
    signTransaction: (userId: string, walletId: string, body: signTransactionBody) => Promise<any>;
    refreshKeys: (userId: string, walletId: string, oldPartnerId?: string, newPartnerId?: string, keyShareProtocolId?: string) => Promise<any>;
    updatePregenWallet: (walletId: string, body: updatePregenWalletBody) => Promise<any>;
    getWallets: (userId: string, includePartnerData?: boolean) => Promise<AxiosResponse<GetWalletsRes, any>>;
    getAllWallets: (userId: string) => Promise<AxiosResponse<GetWalletsRes, any>>;
    setCurrentWalletIds: (userId: string, walletIds: CurrentWalletIds, needsWallet?: boolean, sessionLookupId?: string, newDeviceSessionLookupId?: string) => Promise<any>;
    login: (props: {
        email: string;
    } & VerificationEmailProps) => Promise<any>;
    verifyLogin: (verificationCode: string) => Promise<any>;
    logout: () => Promise<any>;
    recoveryVerification: (email: string, verificationCode: string) => Promise<any>;
    recoveryInit: (email: string) => Promise<any>;
    preSignMessage: (userId: string, walletId: string, message: string, scheme?: WalletScheme, cosmosSignDoc?: string) => Promise<any>;
    deleteSelf: (userId: string) => Promise<any>;
    uploadKeyshares(userId: string, walletId: string, encryptedKeyshares: EncryptedKeyShare[]): Promise<any>;
    uploadUserKeyShares(userId: string, encryptedKeyshares: (EncryptedKeyShare & {
        walletId: string;
    })[]): Promise<any>;
    getKeyshare(userId: string, walletId: string, type: KeyShareType, encryptor?: EncryptorType): Promise<any>;
    getBiometricKeyshares(userId: string, biometricPublicKey: string, getAll?: boolean): Promise<any>;
    getPasswordKeyshares(userId: string, passwordId: string, getAll?: boolean): Promise<any>;
    uploadTransmissionKeyshares(userId: string, shares: {
        walletId: string;
        encryptedShare: string;
        encryptedKey?: string;
        sessionLookupId: string;
    }[]): Promise<any>;
    getTransmissionKeyshares(userId: string, sessionLookupId: string): Promise<any>;
    getParaShare: (userId: string, walletId: string) => Promise<string>;
    getBackupKit: (userId: string) => Promise<any>;
    resendVerificationCode({ userId, ...rest }: {
        userId: string;
    } & VerificationEmailProps): Promise<AxiosResponse<any, any>>;
    resendVerificationCodeByPhone({ userId, ...rest }: {
        userId: string;
    } & VerificationEmailProps): Promise<AxiosResponse<any, any>>;
    cancelRecoveryAttempt(email: string): Promise<AxiosResponse<any, any>>;
    check2FAStatus(userId: string): Promise<AxiosResponse<any, any>>;
    enable2FA(userId: string, verificationCode: string): Promise<AxiosResponse<any, any>>;
    setup2FA(userId: string): Promise<AxiosResponse<any, any>>;
    initializeRecovery(email: string): Promise<AxiosResponse<any, any>>;
    initializeFarcasterLogin(): Promise<AxiosResponse<any, any>>;
    getFarcasterAuthStatus(): Promise<AxiosResponse<any, any>>;
    initializeRecoveryForPhone(phone: string, countryCode: string): Promise<AxiosResponse<any, any>>;
    finalizeRecovery(userId: string, walletId: string): Promise<AxiosResponse<any, any>>;
    recoverUserShares(userId: string, walletId: string): Promise<AxiosResponse<{
        keyShare: {
            encryptedShare: string;
            encryptedKey?: string;
            type: string;
            walletId: string;
        };
        keyShares: {
            encryptedShare: string;
            encryptedKey?: string;
            type: string;
            walletId: string;
        }[];
    }, any>>;
    verifyEmailForRecovery(email: string, verificationCode: string): Promise<AxiosResponse<any, any>>;
    verifyPhoneForRecovery(phone: string, countryCode: string, verificationCode: string): Promise<AxiosResponse<any, any>>;
    verify2FA(email: string, verificationCode: string): Promise<AxiosResponse<any, any>>;
    verify2FAForPhone(phone: string, countryCode: string, verificationCode: string): Promise<AxiosResponse<any, any>>;
    tempTrasmissionInit(message: string, userId?: string): Promise<AxiosResponse<any, any>>;
    tempTrasmission(id: string): Promise<AxiosResponse<any, any>>;
    getPartner(partnerId: string): Promise<AxiosResponse<any, any>>;
    acceptScopes(userId: string, walletId: string, body: AcceptScopesBody): Promise<AxiosResponse<any, any>>;
    getPendingTransaction(userId: string, pendingTransactionId: string): Promise<AxiosResponse<any, any>>;
    acceptPendingTransaction(userId: string, pendingTransactionId: string): Promise<AxiosResponse<any, any>>;
    getOnRampConfig(): Promise<OnRampConfig>;
    createOnRampPurchase({ userId, params: { type, walletType, address, provider, networks, assets, defaultNetwork, defaultAsset, fiat, fiatQuantity, testMode, }, ...params }: {
        userId: string;
        params: OnRampPurchaseCreateParams;
    } & WalletParams): Promise<OnRampPurchase>;
    updateOnRampPurchase({ userId, purchaseId, updates, ...params }: {
        userId: string;
        purchaseId: string;
        updates: OnRampPurchaseUpdateParams;
    } & WalletParams): Promise<OnRampPurchase>;
    getOnRampPurchase({ userId, purchaseId, ...params }: {
        userId: string;
        purchaseId: string;
    } & WalletParams): Promise<AxiosResponse<OnRampPurchase, any>>;
    signMoonPayUrl(userId: string, { url, type, cosmosPrefix, testMode, walletId, externalWalletAddress, }: {
        url: string;
        type: WalletType;
        cosmosPrefix: string;
        testMode?: boolean;
        walletId?: string;
        externalWalletAddress?: string;
    }): Promise<AxiosResponse<{
        signature: string;
    }, any>>;
    generateOffRampTx<ReturnType = {
        tx: string;
        asset: OnRampAsset;
        network: Network;
    }>(userId: string, { provider, chainId, contractAddress, testMode, walletId, walletType, destinationAddress, sourceAddress, assetQuantity, }: {
        provider: OnRampProvider;
        chainId: string;
        contractAddress?: string;
        testMode?: boolean;
        walletId: string;
        walletType: WalletType;
        destinationAddress: string;
        sourceAddress?: string;
        assetQuantity: string | number;
    }): Promise<ReturnType>;
    sendOffRampTx<ReturnType = {
        txHash: string;
    }>(userId: string, { tx, signature, network, walletId, walletType, }: {
        tx: string;
        signature: string;
        network: Network;
        walletId: string;
        walletType: WalletType;
    }): Promise<ReturnType>;
    distributeParaShare({ userId, walletId, ...rest }: {
        userId: string;
        walletId: string;
        useDKLS: boolean;
    } & BackupKitEmailProps): Promise<AxiosResponse<any, any>>;
    keepSessionAlive(userId: string): Promise<any>;
    persistRecoveryPublicKeys(userId: string, publicKeys: string[]): Promise<{
        recoveryPublicKeys: {
            id: string;
            publicKey: string;
        }[];
    }>;
    getRecoveryPublicKeys(userId: string): Promise<{
        recoveryPublicKeys: {
            id: string;
            publicKey: string;
        }[];
    }>;
    uploadEncryptedWalletPrivateKey(userId: string, encryptedWalletPrivateKey: string, encryptionKeyHash: string, biometricPublicKey?: string, passwordId?: string): Promise<any>;
    getEncryptedWalletPrivateKeys(userId: string, encryptionKeyHash: string): Promise<any>;
    getConversionRate(chainId: string, symbol: string, currency: string): Promise<any>;
    getGasEstimate(chainId: string, totalGasPrice: string): Promise<any>;
    getGasOracle(chainId: string): Promise<any>;
    isRefreshDone(userId: string, walletId: string, partnerId?: string, protocolId?: string): Promise<{
        isDone: true;
    }>;
    deletePendingTransaction(userId: string, pendingTransactionId: string): Promise<any>;
    addSessionPasswordPublicKey(userId: string, body: sessionPasswordBody): Promise<any>;
    patchSessionPassword: (partnerId: string, userId: string, passwordId: string, body: sessionPasswordBody) => Promise<any>;
    getSupportedAuthMethods(auth: Auth): Promise<any>;
    getPasswords(auth: Auth): Promise<PasswordEntity[]>;
    verifyPasswordChallenge(partnerId: string, body: verifyPasswordChallengeBody): Promise<any>;
    getEncryptedWalletPrivateKey(passwordId: string): Promise<any>;
    getUser(userId: string): Promise<any>;
}
export default Client;
