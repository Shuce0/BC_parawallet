var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import base64url from 'base64url';
import forge from 'node-forge';
import { getPortalBaseURL } from '../utils/index.js';
const rsa = forge.pki.rsa;
const RSA_ENCRYPTION_SCHEME = 'RSA-OAEP';
// ivs can be constant only because every key is only ever used to encrypt one message
const CONSTANT_IV = '794241bc819a125a7b78ea313decc0bc';
const CONSTANT_IV_AES = new Uint8Array([23, 66, 157, 146, 179, 158, 117, 120, 184, 73, 123, 81]);
export function getSHA256HashHex(str) {
    const md = forge.md.sha256.create();
    md.update(str);
    return md.digest().toHex();
}
export function getPublicKeyHex(keyPair) {
    const pem = forge.pki.publicKeyToRSAPublicKeyPem(keyPair.publicKey);
    return Buffer.from(pem, 'utf-8').toString('hex');
}
export function publicKeyFromHex(publicKeyHex) {
    const pem = publicKeyHexToPem(publicKeyHex);
    return forge.pki.publicKeyFromPem(pem);
}
export function publicKeyHexToPem(publicKeyHex) {
    return Buffer.from(publicKeyHex, 'hex').toString('utf-8');
}
export function encodePrivateKeyToPemHex(keyPair) {
    const pem = forge.pki.privateKeyToPem(keyPair.privateKey);
    return Buffer.from(pem, 'utf-8').toString('hex');
}
export function decodePrivateKeyPemHex(privateKeyPemHex) {
    const pem = Buffer.from(privateKeyPemHex, 'hex').toString('utf-8');
    return forge.pki.privateKeyFromPem(pem);
}
export function encryptPrivateKey(keyPair, key) {
    return __awaiter(this, void 0, void 0, function* () {
        const privateKeyPemHex = encodePrivateKeyToPemHex(keyPair);
        const cryptoKey = yield window.crypto.subtle.importKey('raw', Buffer.from(key, 'base64'), {
            name: 'AES-GCM',
            length: 256,
        }, true, ['encrypt', 'decrypt']);
        const encodedPlaintext = new TextEncoder().encode(privateKeyPemHex);
        const ciphertext = yield window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: CONSTANT_IV_AES }, cryptoKey, encodedPlaintext);
        return Buffer.from(ciphertext).toString('base64');
    });
}
export function decryptPrivateKey(encryptedPrivateKeyPemHex, key) {
    return __awaiter(this, void 0, void 0, function* () {
        const secretKey = yield crypto.subtle.importKey('raw', Buffer.from(key, 'base64'), {
            name: 'AES-GCM',
            length: 256,
        }, true, ['encrypt', 'decrypt']);
        const cleartext = yield crypto.subtle.decrypt({ name: 'AES-GCM', iv: CONSTANT_IV_AES }, secretKey, Buffer.from(encryptedPrivateKeyPemHex, 'base64'));
        const privateKeyPemHex = new TextDecoder().decode(cleartext);
        const privateKey = decodePrivateKeyPemHex(privateKeyPemHex);
        return privateKey;
    });
}
export function getAsymmetricKeyPair(ctx, seedValue) {
    return __awaiter(this, void 0, void 0, function* () {
        const prng = forge.random.createInstance();
        if (seedValue) {
            prng.seedFileSync = (_n) => seedValue;
            prng.seedFile = (_n, cb) => {
                cb(null, seedValue);
            };
        }
        const options = {
            bits: 2048,
            e: 65537,
            prng,
        };
        if (!ctx.disableWorkers) {
            options.workLoad = 100;
            // only using 1 web worker as more makes the call non-deterministic
            // -1 uses optimal amount of web workers
            options.workers = seedValue ? 1 : -1;
            const workerRes = yield fetch(`${getPortalBaseURL(ctx)}/static/js/prime.worker.min.js`);
            const workerBlob = new Blob([yield workerRes.text()], { type: 'application/javascript' });
            options.workerScript = URL.createObjectURL(workerBlob);
        }
        return new Promise((resolve, reject) => rsa.generateKeyPair(options, (err, keypair) => {
            if (err) {
                reject(err);
            }
            resolve(keypair);
        }));
    });
}
export function getPublicKeyFromSignature(ctx, userHandle) {
    return __awaiter(this, void 0, void 0, function* () {
        const encodedUserHandle = base64url.encode(userHandle);
        const keyPair = yield getAsymmetricKeyPair(ctx, encodedUserHandle);
        return getPublicKeyHex(keyPair);
    });
}
// only use for one time key encryptions as iv is constant
export function symmetricKeyEncryptMessage(message) {
    const key = forge.random.getBytesSync(16);
    const cipher = forge.cipher.createCipher('AES-CBC', key);
    // iv can be constant only because every key is only ever used to encrypt one message
    cipher.start({ iv: CONSTANT_IV });
    cipher.update(forge.util.createBuffer(message));
    cipher.finish();
    const encryptedMessageHex = cipher.output.toHex();
    return { key, encryptedMessageHex };
}
function decipherEncryptedMessageHex(key, encryptedMessageHex) {
    const decipher = forge.cipher.createDecipher('AES-CBC', key);
    // iv can be constant only because every key is only ever used to encrypt one message
    decipher.start({ iv: CONSTANT_IV });
    decipher.update(forge.util.createBuffer(forge.util.hexToBytes(encryptedMessageHex)));
    decipher.finish();
    return decipher.output.toString();
}
// Deprecated in favor of decryptWithPrivateKey
export function decryptWithKeyPair(keyPair, encryptedMessageHex, encryptedKeyHex) {
    const encryptedKey = Buffer.from(encryptedKeyHex, 'hex').toString('utf-8');
    const key = keyPair.privateKey.decrypt(encryptedKey, RSA_ENCRYPTION_SCHEME);
    return decipherEncryptedMessageHex(key, encryptedMessageHex);
}
export function decryptWithPrivateKey(privateKey, encryptedMessageHex, encryptedKeyHex) {
    const encryptedKey = Buffer.from(encryptedKeyHex, 'hex').toString('utf-8');
    const key = privateKey.decrypt(encryptedKey, RSA_ENCRYPTION_SCHEME);
    return decipherEncryptedMessageHex(key, encryptedMessageHex);
}
function decryptWithDerivedPrivateKey(ctx, { seedValue, encryptedMessageHex, encryptedKeyHex, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const keyPair = yield getAsymmetricKeyPair(ctx, seedValue);
        return decryptWithPrivateKey(keyPair.privateKey, encryptedMessageHex, encryptedKeyHex);
    });
}
export function getDerivedPrivateKeyAndDecrypt(ctx, seedValue, encryptedShares) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.all(encryptedShares.map((share) => __awaiter(this, void 0, void 0, function* () {
            return ({
                walletId: share.walletId,
                walletScheme: share.walletScheme,
                partnerId: share.partnerId,
                signer: yield decryptWithDerivedPrivateKey(ctx, {
                    seedValue,
                    encryptedMessageHex: share.encryptedShare,
                    encryptedKeyHex: share.encryptedKey,
                }),
                protocolId: share.protocolId,
            });
        })));
    });
}
export function decryptPrivateKeyAndDecryptShare(encryptionKey, encryptedShares, encryptedPrivateKey) {
    return __awaiter(this, void 0, void 0, function* () {
        let privateKey;
        try {
            privateKey = yield decryptPrivateKey(encryptedPrivateKey, encryptionKey);
        }
        catch (e) { }
        try {
            privateKey = yield decryptPrivateKeyWithPassword(encryptedPrivateKey, encryptionKey);
        }
        catch (e) { }
        if (!privateKey) {
            throw new Error('Could not decrypt private key');
        }
        return encryptedShares.map(share => ({
            walletId: share.walletId,
            walletScheme: share.walletScheme,
            partnerId: share.partnerId,
            signer: decryptWithPrivateKey(privateKey, share.encryptedShare, share.encryptedKey),
            protocolId: share.protocolId,
        }));
    });
}
export function encryptWithDerivedPublicKey(publicKeyHex, message) {
    const { key, encryptedMessageHex } = symmetricKeyEncryptMessage(message);
    const publicKeyPem = publicKeyHexToPem(publicKeyHex);
    const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);
    const encryptedKey = publicKey.encrypt(key, RSA_ENCRYPTION_SCHEME);
    const encryptedKeyHex = Buffer.from(encryptedKey, 'utf-8').toString('hex');
    return { encryptedMessageHex, encryptedKeyHex };
}
export function hashPasswordWithSalt(password) {
    const salt = generateSalt();
    const saltedPassword = salt + password;
    const hash = getSHA256HashHex(saltedPassword);
    return { salt, hash };
}
function generateSalt(length = 16) {
    return forge.util.bytesToHex(forge.random.getBytesSync(length));
}
function deriveCryptoKeyFromPassword(hashedPassword) {
    return __awaiter(this, void 0, void 0, function* () {
        const keyBuffer = Buffer.from(hashedPassword, 'hex');
        return yield window.crypto.subtle.importKey('raw', keyBuffer, {
            name: 'AES-GCM',
            length: 256,
        }, true, ['encrypt', 'decrypt']);
    });
}
export function encryptPrivateKeyWithPassword(keyPair, hashedPassword) {
    return __awaiter(this, void 0, void 0, function* () {
        const cryptoKey = yield deriveCryptoKeyFromPassword(hashedPassword);
        const privateKeyPemHex = encodePrivateKeyToPemHex(keyPair);
        const encodedPlaintext = new TextEncoder().encode(privateKeyPemHex);
        const ciphertext = yield window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: CONSTANT_IV_AES }, cryptoKey, encodedPlaintext);
        return Buffer.from(ciphertext).toString('base64');
    });
}
export function decryptPrivateKeyWithPassword(encryptedPrivateKeyPemHex, hashedPassword) {
    return __awaiter(this, void 0, void 0, function* () {
        const secretKey = yield crypto.subtle.importKey('raw', Buffer.from(hashedPassword, 'hex'), {
            name: 'AES-GCM',
            length: 256,
        }, true, ['encrypt', 'decrypt']);
        const cleartext = yield crypto.subtle.decrypt({ name: 'AES-GCM', iv: CONSTANT_IV_AES }, secretKey, Buffer.from(encryptedPrivateKeyPemHex, 'base64'));
        const privateKeyPemHex = new TextDecoder().decode(cleartext);
        const privateKey = decodePrivateKeyPemHex(privateKeyPemHex);
        return privateKey;
    });
}
