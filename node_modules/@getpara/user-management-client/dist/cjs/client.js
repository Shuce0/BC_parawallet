"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleResponseError = exports.handleResponseSuccess = void 0;
const axios_1 = __importDefault(require("axios"));
const qs_1 = __importDefault(require("qs"));
const utils_js_1 = require("./utils.js");
const consts_js_1 = require("./consts.js");
const error_js_1 = require("./error.js");
const handleResponseSuccess = (response) => {
    if (response.status === 200) {
        return response;
    }
    throw new error_js_1.ParaApiError('Invalid status code');
};
exports.handleResponseSuccess = handleResponseSuccess;
const handleResponseError = (error) => {
    var _a, _b, _c;
    if (error === null)
        throw new error_js_1.ParaApiError('Error is null');
    if (axios_1.default.isAxiosError(error)) {
        let message = (_b = (_a = error.response) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : 'Unknown error';
        // Add meaningful messages to connection errors
        // Can do this for other Axios codes as well in the future if we need: https://github.com/axios/axios/blob/v1.x/lib/core/AxiosError.js#L61
        if (error.code === 'ERR_NETWORK') {
            message = 'Connection error';
        }
        else if (error.code === 'ERR_CANCELED') {
            message = 'Connection canceled';
        }
        throw new error_js_1.ParaApiError(message, error.code, error.response.status, (_c = error.request) === null || _c === void 0 ? void 0 : _c.responseURL);
    }
    throw new error_js_1.ParaApiError('Unknown error');
};
exports.handleResponseError = handleResponseError;
class Client {
    constructor({ userManagementHost, apiKey, partnerId, version, opts, retrieveSessionCookie, persistSessionCookie, }) {
        this.createUser = (body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users`, body);
            return res.data;
        });
        this.checkUserExists = (auth) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get('/users/exists', {
                params: Object.assign({}, auth),
            });
            return res;
        });
        this.verifyTelegram = (authObject) => __awaiter(this, void 0, void 0, function* () {
            return (yield this.baseRequest.post('/users/telegram', {
                authObject,
            })).data;
        });
        this.externalWalletLogin = (body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users/external-wallets/login`, body);
            return res.data;
        });
        // POST /users/:userId/verify-email
        this.verifyEmail = (userId, body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users/${userId}/verify-email`, body);
            return res;
        });
        this.verifyPhone = (userId, body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users/${userId}/verify-identifier`, body);
            return res;
        });
        // POST /users/:userId/biometrics/key
        this.addSessionPublicKey = (userId, body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users/${userId}/biometrics/key`, body);
            return res;
        });
        // GET /users/:userId/biometrics/keys
        this.getSessionPublicKeys = (userId) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}/biometrics/keys`);
            return res;
        });
        // GET /biometrics/location-hints
        this.getBiometricLocationHints = (params) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/biometrics/location-hints`, { params });
            return res.data.hints;
        });
        // GET /users/:userId/biometrics/:biometricId
        this.getSessionPublicKey = (userId, biometricId) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}/biometrics/${biometricId}`);
            return res;
        });
        // PATCH /users/:userId/biometrics/:biometricId
        this.patchSessionPublicKey = (partnerId, userId, biometricId, body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.patch(`/users/${userId}/biometrics/${biometricId}`, body, {
                headers: {
                    [consts_js_1.PARTNER_ID_HEADER_NAME]: partnerId,
                },
            });
            return res;
        });
        // GET /biometrics/challenge?email&publicKey
        this.getWebChallenge = (auth) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get('/biometrics/challenge', {
                params: Object.assign({}, (auth || {})),
            });
            return res.data;
        });
        // POST /touch
        this.touchSession = (regenerate) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/touch?regenerate=${!!regenerate}`);
            return res;
        });
        // GET /session/origin
        this.sessionOrigin = (sessionLookupId) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/sessions/${sessionLookupId}/origin`);
            return res.data;
        });
        // POST /biometrics/verify
        this.verifyWebChallenge = (partnerId, body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/biometrics/verify`, body, {
                headers: {
                    [consts_js_1.PARTNER_ID_HEADER_NAME]: partnerId,
                },
            });
            return res;
        });
        // GET /users/:userId/biometrics/challenge
        this.getSessionChallenge = (userId) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}/biometrics/challenge`);
            return res;
        });
        // POST /users/:userId/biometrics/verify
        this.verifySessionChallenge = (userId, body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users/${userId}/biometrics/verify`, body);
            return res;
        });
        // POST /users/:userId/wallets
        this.createWallet = (userId, body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users/${userId}/wallets`, body);
            return res.data;
        });
        // POST /wallets/pregen
        this.createPregenWallet = (body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/wallets/pregen`, body);
            return res.data;
        });
        // GET /wallets/pregen?pregenIdentifier={pregenIdentifier}&pregenIdentifierType={pregenIdentifierType}
        this.getPregenWallets = (pregenIds_1, ...args_1) => __awaiter(this, [pregenIds_1, ...args_1], void 0, function* (pregenIds, isPortal = false, userId) {
            const res = yield this.baseRequest.get('/wallets/pregen', {
                params: { ids: pregenIds, expand: isPortal, userId },
            });
            return res.data;
        });
        // POST /wallets/pregen/claim
        this.claimPregenWallets = (body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/wallets/pregen/claim`, body);
            return res.data;
        });
        // POST /users/:userId/wallets/:walletId/transactions/send
        this.sendTransaction = (userId, walletId, body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/transactions/send`, body);
            return res;
        });
        // functionality changed to only sign transactions and not send them
        // POST /users/:userId/wallets/:walletId/transactions/sign
        this.signTransaction = (userId, walletId, body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/transactions/sign`, body);
            return res;
        });
        // POST /users/:userId/wallets/:walletId/refresh
        this.refreshKeys = (userId, walletId, oldPartnerId, newPartnerId, keyShareProtocolId) => __awaiter(this, void 0, void 0, function* () {
            const body = { oldPartnerId, newPartnerId, keyShareProtocolId };
            const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/refresh`, body);
            return res;
        });
        // PATCH /wallets/pregen/:walletId
        this.updatePregenWallet = (walletId, body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.patch(`/wallets/pregen/${walletId}`, body);
            return res.data;
        });
        // GET /users/:userId/wallets
        this.getWallets = (userId, includePartnerData) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}/wallets${includePartnerData ? `?includePartnerData=${encodeURIComponent(includePartnerData)}` : ''}`);
            return res;
        });
        // GET /users/:userId/all-wallets
        this.getAllWallets = (userId) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}/all-wallets`);
            return res;
        });
        // POST /users/:userId/wallets/set
        this.setCurrentWalletIds = (userId_1, walletIds_1, ...args_1) => __awaiter(this, [userId_1, walletIds_1, ...args_1], void 0, function* (userId, walletIds, needsWallet = false, sessionLookupId, newDeviceSessionLookupId) {
            const res = yield this.baseRequest.post(`/users/${userId}/wallets/set`, {
                walletIds,
                needsWallet,
                sessionLookupId,
                newDeviceSessionLookupId,
            });
            return res;
        });
        // POST /login
        this.login = (props) => __awaiter(this, void 0, void 0, function* () {
            const body = props;
            const res = yield this.baseRequest.post('/login', body);
            return res;
        });
        // POST /login
        this.verifyLogin = (verificationCode) => __awaiter(this, void 0, void 0, function* () {
            const body = { verificationCode };
            const res = yield this.baseRequest.post('/login/verify-email', body);
            return res;
        });
        // GET /logout
        this.logout = () => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get('/logout');
            return res;
        });
        // POST /recovery/verification
        this.recoveryVerification = (email, verificationCode) => __awaiter(this, void 0, void 0, function* () {
            const body = { email, verificationCode };
            const res = yield this.baseRequest.post('/recovery/verification', body);
            return res;
        });
        // POST /recovery
        this.recoveryInit = (email) => __awaiter(this, void 0, void 0, function* () {
            const body = { email };
            const res = yield this.baseRequest.post('/recovery', body);
            return res;
        });
        this.preSignMessage = (userId, walletId, message, scheme, cosmosSignDoc) => __awaiter(this, void 0, void 0, function* () {
            const body = { message, scheme, cosmosSignDoc };
            const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/messages/sign`, body);
            return res.data;
        });
        //DELETE /users/:userId
        this.deleteSelf = (userId) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.delete(`/users/${userId}`);
            return res;
        });
        // GET /users/:userId/wallets/:walletId/capsule-share
        this.getParaShare = (userId, walletId) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}/wallets/${walletId}/capsule-share`);
            return res.data.share;
        });
        // GET /download-backup-kit/:userId
        this.getBackupKit = (userId) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/download-backup-kit/${userId}`, { responseType: 'blob' });
            return res;
        });
        // PATCH /users/:userId/biometrics/:biometricId
        this.patchSessionPassword = (partnerId, userId, passwordId, body) => __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.patch(`/users/${userId}/passwords/${passwordId}`, body, {
                headers: {
                    [consts_js_1.PARTNER_ID_HEADER_NAME]: partnerId,
                },
            });
            return res;
        });
        // TODO remove after this is not optional anymore
        const headers = Object.assign(Object.assign({}, (apiKey && { [consts_js_1.API_KEY_HEADER_NAME]: apiKey })), (partnerId && { [consts_js_1.PARTNER_ID_HEADER_NAME]: partnerId }));
        const axiosConfig = {
            baseURL: userManagementHost,
            withCredentials: true,
            headers,
        };
        if (retrieveSessionCookie) {
            const defaultTransformRequest = Array.isArray(axios_1.default.defaults.transformRequest)
                ? axios_1.default.defaults.transformRequest
                : [axios_1.default.defaults.transformRequest];
            axiosConfig.transformRequest = [
                function (data, headers) {
                    const currentSessionCookie = retrieveSessionCookie();
                    if (currentSessionCookie) {
                        headers[consts_js_1.SESSION_COOKIE_HEADER_NAME] = currentSessionCookie;
                    }
                    if (version) {
                        headers[consts_js_1.VERSION_HEADER_NAME] = version;
                    }
                    return data;
                },
                ...defaultTransformRequest,
            ];
        }
        if (persistSessionCookie) {
            const defaultTransformResponse = Array.isArray(axios_1.default.defaults.transformResponse)
                ? axios_1.default.defaults.transformResponse
                : [axios_1.default.defaults.transformResponse];
            axiosConfig.transformResponse = [
                ...defaultTransformResponse,
                function (data, headers, _status) {
                    if (headers === null || headers === void 0 ? void 0 : headers[consts_js_1.SESSION_COOKIE_HEADER_NAME]) {
                        persistSessionCookie(headers[consts_js_1.SESSION_COOKIE_HEADER_NAME]);
                    }
                    return data;
                },
            ];
        }
        this.baseRequest = axios_1.default.create(axiosConfig);
        if (opts === null || opts === void 0 ? void 0 : opts.useFetchAdapter) {
            axios_1.default.defaults.adapter = function (config) {
                return fetch(config.baseURL + config.url.substring(1), {
                    method: config.method,
                    headers: config.headers,
                    body: config.data,
                    credentials: config.withCredentials ? 'include' : undefined,
                })
                    .then(response => response.text().then(text => ({
                    data: text,
                    status: response.status,
                    statusText: response.statusText,
                    headers: response.headers,
                    config: config,
                    request: fetch,
                })))
                    .catch(function (reason) {
                    throw reason;
                });
            };
        }
        // Intercept response to add more concise errors rather than returning the entire AxiosError
        this.baseRequest.interceptors.response.use(exports.handleResponseSuccess, exports.handleResponseError);
    }
    // DEPRECATED: use uploadUserKeyShares instead
    // POST /users/:userId/wallets/:walletId/key-shares
    uploadKeyshares(userId, walletId, encryptedKeyshares) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { keyShares: encryptedKeyshares };
            const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/key-shares`, body);
            return res;
        });
    }
    // POST /users/:userId/key-shares
    uploadUserKeyShares(userId, encryptedKeyshares) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { keyShares: encryptedKeyshares };
            const res = yield this.baseRequest.post(`/users/${userId}/key-shares`, body);
            return res;
        });
    }
    // GET /users/:userId/wallets/:walletId/key-shares
    getKeyshare(userId, walletId, type, encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}/wallets/${walletId}/key-shares?type=${type}${encryptor ? `&encryptor=${encryptor}` : ''}`);
            return res;
        });
    }
    // GET /users/:userId/biometrics/key-shares
    getBiometricKeyshares(userId, biometricPublicKey, getAll) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}/biometrics/key-shares?publicKey=${biometricPublicKey}&all=${!!getAll}`);
            return res;
        });
    }
    // GET /users/:userId/key-shares
    getPasswordKeyshares(userId, passwordId, getAll) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}/passwords/key-shares?passwordId=${passwordId}&all=${!!getAll}`);
            return res;
        });
    }
    // POST '/users/:userId/temporary-shares',
    uploadTransmissionKeyshares(userId, shares) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { shares };
            const res = yield this.baseRequest.post(`/users/${userId}/temporary-shares`, body);
            return res;
        });
    }
    // GET /users/:userId/temporary-shares returns { temporaryShares: { userId: string, walletId: string, encryptedShare: string, encryptedKey?: string }[] }
    getTransmissionKeyshares(userId, sessionLookupId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}/temporary-shares?sessionLookupId=${sessionLookupId}`);
            return res;
        });
    }
    // POST '/users/:userId/resend-verification-code
    resendVerificationCode(_a) {
        return __awaiter(this, void 0, void 0, function* () {
            var { userId } = _a, rest = __rest(_a, ["userId"]);
            const res = yield this.baseRequest.post(`/users/${userId}/resend-verification-code`, rest);
            return res;
        });
    }
    // POST '/users/:userId/resend-verification-code-by-phone
    resendVerificationCodeByPhone(_a) {
        return __awaiter(this, void 0, void 0, function* () {
            var { userId } = _a, rest = __rest(_a, ["userId"]);
            const res = yield this.baseRequest.post(`/users/${userId}/resend-verification-code-by-phone`, rest);
            return res;
        });
    }
    // POST recovery/cancel
    cancelRecoveryAttempt(email) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/recovery/cancel`, { email });
            return res;
        });
    }
    // GET '/2fa/users/:userId/check-status'
    check2FAStatus(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/2fa/users/${userId}/check-status`);
            return res;
        });
    }
    // POST '/2fa/users/:userId/enable'
    enable2FA(userId, verificationCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/2fa/users/${userId}/enable`, { verificationCode });
            return res;
        });
    }
    // POST '/2fa/users/:userId/setup'
    setup2FA(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/2fa/users/${userId}/setup`);
            return res;
        });
    }
    // POST /recovery/init
    initializeRecovery(email) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/recovery/init`, { email });
            return res;
        });
    }
    // POST /auth/farcaster/init
    initializeFarcasterLogin() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/auth/farcaster/init`);
            return res;
        });
    }
    // POST /auth/farcaster/status
    getFarcasterAuthStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/auth/farcaster/status`);
            return res;
        });
    }
    // POST /recovery/init
    initializeRecoveryForPhone(phone, countryCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/recovery/init`, { phone, countryCode });
            return res;
        });
    }
    // POST /recovery/users/:userId/wallets/:walletId/finish
    finalizeRecovery(userId, walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/recovery/users/${userId}/wallets/${walletId}/finish`);
            return res;
        });
    }
    // GET /recovery/users/:userId/wallets/:walletId/key-shares
    recoverUserShares(userId, walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/recovery/users/${userId}/wallets/${walletId}/key-shares?type=USER&encryptor=RECOVERY`);
            return res;
        });
    }
    // POST /recovery/verify-email
    verifyEmailForRecovery(email, verificationCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { email, verificationCode };
            const res = yield this.baseRequest.post(`/recovery/verify-email`, body);
            return res;
        });
    }
    // POST /recovery/verify-identifier
    verifyPhoneForRecovery(phone, countryCode, verificationCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { phone, countryCode, verificationCode };
            const res = yield this.baseRequest.post(`/recovery/verify-identifier`, body);
            return res;
        });
    }
    // POST /2fa/verify
    verify2FA(email, verificationCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { email, verificationCode };
            const res = yield this.baseRequest.post('/2fa/verify', body);
            return res;
        });
    }
    // POST /2fa/phone/verify
    verify2FAForPhone(phone, countryCode, verificationCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { phone, countryCode, verificationCode };
            const res = yield this.baseRequest.post('/2fa/verify', body);
            return res;
        });
    }
    tempTrasmissionInit(message, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { message, userId };
            const res = yield this.baseRequest.post('/temporary-transmissions', body);
            return res;
        });
    }
    tempTrasmission(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/temporary-transmissions/${id}`);
            return res;
        });
    }
    getPartner(partnerId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/partners/${partnerId}`);
            return res;
        });
    }
    acceptScopes(userId, walletId, body) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/scopes/accept`, body);
            return res;
        });
    }
    getPendingTransaction(userId, pendingTransactionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}/pending-transactions/${pendingTransactionId}`);
            return res;
        });
    }
    acceptPendingTransaction(userId, pendingTransactionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users/${userId}/pending-transactions/${pendingTransactionId}/accept`);
            return res;
        });
    }
    getOnRampConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/on-ramp-config`);
            return res.data;
        });
    }
    createOnRampPurchase(_a) {
        return __awaiter(this, void 0, void 0, function* () {
            var { userId, params: { type, walletType, address, provider, networks, assets, defaultNetwork, defaultAsset, fiat, fiatQuantity, testMode = false, } } = _a, params = __rest(_a, ["userId", "params"]);
            const [key, identifier] = (0, utils_js_1.extractWalletRef)(params);
            const walletString = key === 'walletId' ? `wallets/${identifier}` : `external-wallets/${identifier}`;
            const res = yield this.baseRequest.post(`/users/${userId}/${walletString}/purchases`, {
                type,
                provider,
                walletType,
                address,
                networks,
                assets,
                defaultAsset,
                defaultNetwork,
                fiat,
                fiatQuantity,
                testMode,
            });
            return res.data;
        });
    }
    updateOnRampPurchase(_a) {
        return __awaiter(this, void 0, void 0, function* () {
            var { userId, purchaseId, updates } = _a, params = __rest(_a, ["userId", "purchaseId", "updates"]);
            const [key, identifier] = (0, utils_js_1.extractWalletRef)(params);
            const walletString = key === 'walletId' ? `wallets/${identifier}` : `external-wallets/${identifier}`;
            const res = yield this.baseRequest.patch(`/users/${userId}/${walletString}/purchases/${purchaseId}`, updates);
            return res.data;
        });
    }
    getOnRampPurchase(_a) {
        return __awaiter(this, void 0, void 0, function* () {
            var { userId, purchaseId } = _a, params = __rest(_a, ["userId", "purchaseId"]);
            const [key, identifier] = (0, utils_js_1.extractWalletRef)(params);
            const walletString = key === 'walletId' ? `wallets/${identifier}` : `external-wallets/${identifier}`;
            const res = yield this.baseRequest.get(`/users/${userId}/${walletString}/purchases/${purchaseId}`);
            return res;
        });
    }
    signMoonPayUrl(userId_1, _a) {
        return __awaiter(this, arguments, void 0, function* (userId, { url, type, cosmosPrefix, testMode, walletId, externalWalletAddress, }) {
            const walletString = walletId ? `wallets/${walletId}` : `external-wallets/${externalWalletAddress}`;
            const res = yield this.baseRequest.post(`/users/${userId}/${walletString}/moonpay-sign`, {
                url,
                type,
                cosmosPrefix,
                testMode,
            });
            return res;
        });
    }
    generateOffRampTx(userId_1, _a) {
        return __awaiter(this, arguments, void 0, function* (userId, { provider, chainId, contractAddress, testMode, walletId, walletType, destinationAddress, sourceAddress, assetQuantity, }) {
            const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/offramp-generate`, {
                provider,
                testMode,
                chainId,
                contractAddress,
                walletId,
                walletType,
                destinationAddress,
                sourceAddress,
                assetQuantity,
            });
            return res.data;
        });
    }
    sendOffRampTx(userId_1, _a) {
        return __awaiter(this, arguments, void 0, function* (userId, { tx, signature, network, walletId, walletType, }) {
            const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/offramp-send`, {
                tx,
                signature,
                network,
                walletType,
            });
            return res.data;
        });
    }
    distributeParaShare(_a) {
        return __awaiter(this, void 0, void 0, function* () {
            var { userId, walletId } = _a, rest = __rest(_a, ["userId", "walletId"]);
            const body = rest;
            const res = yield this.baseRequest.post(`/users/${userId}/wallets/${walletId}/capsule-share/distribute`, body);
            return res;
        });
    }
    keepSessionAlive(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users/${userId}/session/keep-alive`);
            return res.data;
        });
    }
    persistRecoveryPublicKeys(userId, publicKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users/${userId}/recovery-public-keys`, { publicKeys });
            return res.data;
        });
    }
    getRecoveryPublicKeys(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}/recovery-public-keys`);
            return res.data;
        });
    }
    uploadEncryptedWalletPrivateKey(userId, encryptedWalletPrivateKey, encryptionKeyHash, biometricPublicKey, passwordId) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { encryptedWalletPrivateKey, encryptionKeyHash, biometricPublicKey, passwordId };
            const res = yield this.baseRequest.post(`/users/${userId}/encrypted-wallet-private-keys`, body);
            return res.data;
        });
    }
    getEncryptedWalletPrivateKeys(userId, encryptionKeyHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}/encrypted-wallet-private-keys/${encryptionKeyHash}`);
            return res.data;
        });
    }
    getConversionRate(chainId, symbol, currency) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = { symbol, currency };
            const res = yield this.baseRequest.get(`/chains/${chainId}/conversion-rate`, { params });
            return res.data;
        });
    }
    getGasEstimate(chainId, totalGasPrice) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = { totalGasPrice };
            const res = yield this.baseRequest.get(`/chains/${chainId}/gas-estimate`, { params });
            return res.data;
        });
    }
    getGasOracle(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/chains/${chainId}/gas-oracle`);
            return res.data;
        });
    }
    // GET /users/:userId/wallets/:walletId/refresh-done
    isRefreshDone(userId, walletId, partnerId, protocolId) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParams = {};
            if (partnerId)
                queryParams['partnerId'] = partnerId;
            if (protocolId)
                queryParams['protocolId'] = protocolId;
            const query = qs_1.default.stringify(queryParams);
            const res = yield this.baseRequest.get(`/users/${userId}/wallets/${walletId}/refresh-done?${query}`);
            return res.data;
        });
    }
    deletePendingTransaction(userId, pendingTransactionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.delete(`/users/${userId}/pending-transactions/${pendingTransactionId}`);
            return res.data;
        });
    }
    // POST /users/:userId/passwords/key
    addSessionPasswordPublicKey(userId, body) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/users/${userId}/passwords/key`, body);
            return res;
        });
    }
    getSupportedAuthMethods(auth) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get('/users/supported-auth-methods', {
                params: Object.assign({}, auth),
            });
            return res.data;
        });
    }
    getPasswords(auth) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get('/users/passwords', {
                params: Object.assign({}, auth),
            });
            return res.data.passwords;
        });
    }
    // POST /passwords/verify
    verifyPasswordChallenge(partnerId, body) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.post(`/passwords/verify`, body, {
                headers: {
                    [consts_js_1.PARTNER_ID_HEADER_NAME]: partnerId,
                },
            });
            return res;
        });
    }
    getEncryptedWalletPrivateKey(passwordId) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParams = {};
            queryParams['passwordId'] = passwordId;
            const query = qs_1.default.stringify(queryParams);
            const res = yield this.baseRequest.get(`/encrypted-wallet-private-keys?${query}`);
            return res;
        });
    }
    // GET /users/:userId
    getUser(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.baseRequest.get(`/users/${userId}`);
            return res.data;
        });
    }
}
exports.default = Client;
// GET /users/:userId/wallets/:walletId/send (NOTE: endpoint not found in server)
// NOT USED IN DEMO
// POST /users/:userId/wallets/:walletId/presign
// POST /users/:userId/wallets/:walletId/presign-online
// POST /auth/signup/web
// GET /logout
// POST /users/:userId/wallets/:walletId/key
// GET /users/:userId/wallets/:walletId/key
// GET /users/:userId/configurations
// GET /
