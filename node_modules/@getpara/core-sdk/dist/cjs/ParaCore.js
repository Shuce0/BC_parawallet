"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _ParaCore_supportedWalletTypes, _ParaCore_supportedWalletTypesOpt;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParaCore = void 0;
const buffer_1 = require("buffer");
if (typeof global !== 'undefined') {
    global.Buffer = global.Buffer || buffer_1.Buffer;
}
else if (typeof window !== 'undefined') {
    window.Buffer = window.Buffer || buffer_1.Buffer;
    window.global = window.global || window;
}
else {
    self.Buffer = self.Buffer || buffer_1.Buffer;
    self.global = self.global || self;
}
const user_management_client_1 = require("@getpara/user-management-client");
const node_forge_1 = __importDefault(require("node-forge"));
const { pki, jsbn } = node_forge_1.default;
const utils_js_1 = require("./cryptography/utils.js");
const userManagementClient_js_1 = require("./external/userManagementClient.js");
const mpcComputationClient = __importStar(require("./external/mpcComputationClient.js"));
const shareDistribution_js_1 = require("./shares/shareDistribution.js");
const index_js_1 = require("./types/index.js");
const transmissionUtils = __importStar(require("./transmission/transmissionUtils.js"));
const recovery_js_1 = require("./shares/recovery.js");
const index_js_2 = require("./utils/index.js");
const errors_js_1 = require("./errors.js");
const constants = __importStar(require("./constants.js"));
class ParaCore {
    get isEmail() {
        return !!this.email && !this.phone && !this.countryCode && !this.farcasterUsername && !this.telegramUserId;
    }
    get isPhone() {
        return !!this.phone && !!this.countryCode && !this.email && !this.farcasterUsername && !this.telegramUserId;
    }
    get isFarcaster() {
        return !!this.farcasterUsername && !this.email && !this.phone && !this.countryCode && !this.telegramUserId;
    }
    get isTelegram() {
        return !!this.telegramUserId && !this.email && !this.phone && !this.countryCode && !this.farcasterUsername;
    }
    get currentWalletIdsArray() {
        return this.supportedWalletTypes.reduce((acc, { type }) => {
            var _a;
            return [
                ...acc,
                ...((_a = this.currentWalletIds[type]) !== null && _a !== void 0 ? _a : []).map(id => {
                    return [id, type];
                }),
            ];
        }, []);
    }
    get currentWalletIdsUnique() {
        return [...new Set(Object.values(this.currentWalletIds).flat())];
    }
    /**
     * A map of pre-generated wallet identifiers that can be claimed in the current instance.
     */
    get pregenIds() {
        return Object.assign({}, Object.values(this.wallets)
            .filter(wallet => !this.userId || this.isPregenWalletClaimable(wallet))
            .reduce((acc, wallet) => {
            var _a, _b;
            if (((_a = acc[wallet.pregenIdentifierType]) !== null && _a !== void 0 ? _a : []).includes(wallet.pregenIdentifier)) {
                return acc;
            }
            return Object.assign(Object.assign({}, acc), { [wallet.pregenIdentifierType]: [
                    ...new Set([...((_b = acc[wallet.pregenIdentifierType]) !== null && _b !== void 0 ? _b : []), wallet.pregenIdentifier]),
                ] });
        }, {}));
    }
    /**
     * Whether the instance has multiple wallets connected.
     */
    get isMultiWallet() {
        return this.currentWalletIdsArray.length > 1;
    }
    get supportedWalletTypes() {
        var _a;
        return (_a = __classPrivateFieldGet(this, _ParaCore_supportedWalletTypes, "f")) !== null && _a !== void 0 ? _a : [];
    }
    get isWalletTypeEnabled() {
        return this.supportedWalletTypes.reduce((acc, { type }) => {
            return Object.assign(Object.assign({}, acc), { [type]: true });
        }, {});
    }
    convertBigInt(bigInt) {
        const convertedBigInt = new jsbn.BigInteger(null);
        convertedBigInt.data = bigInt.data;
        convertedBigInt.s = bigInt.s;
        convertedBigInt.t = bigInt.t;
        return convertedBigInt;
    }
    convertEncryptionKeyPair(jsonKeyPair) {
        return {
            privateKey: pki.setRsaPrivateKey(this.convertBigInt(jsonKeyPair.privateKey.n), this.convertBigInt(jsonKeyPair.privateKey.e), this.convertBigInt(jsonKeyPair.privateKey.d), this.convertBigInt(jsonKeyPair.privateKey.p), this.convertBigInt(jsonKeyPair.privateKey.q), this.convertBigInt(jsonKeyPair.privateKey.dP), this.convertBigInt(jsonKeyPair.privateKey.dQ), this.convertBigInt(jsonKeyPair.privateKey.qInv)),
            publicKey: pki.setRsaPublicKey(this.convertBigInt(jsonKeyPair.publicKey.n), this.convertBigInt(jsonKeyPair.publicKey.e)),
        };
    }
    isPortal(envOverride) {
        var _a;
        if (typeof window === 'undefined')
            return false;
        return (!!((_a = window.location) === null || _a === void 0 ? void 0 : _a.host) &&
            (0, index_js_2.getPortalBaseURL)(envOverride ? { env: envOverride } : this.ctx).includes(window.location.host));
    }
    isParaConnect() {
        var _a;
        if (typeof window === 'undefined')
            return false;
        return !!((_a = window.location) === null || _a === void 0 ? void 0 : _a.host) && (0, index_js_2.getParaConnectBaseUrl)(this.ctx).includes(window.location.host);
    }
    requireApiKey() {
        if (!this.ctx.apiKey) {
            throw new Error(`in order to create a wallet or user with Para, you
        must provide an API key to the Para instance`);
        }
    }
    isWalletSupported(wallet) {
        var _a;
        return !__classPrivateFieldGet(this, _ParaCore_supportedWalletTypes, "f") || (0, index_js_2.isWalletSupported)((_a = this.supportedWalletTypes.map(({ type }) => type)) !== null && _a !== void 0 ? _a : [], wallet);
    }
    isWalletOwned(wallet) {
        return (this.isWalletSupported(wallet) &&
            !wallet.pregenIdentifier &&
            !wallet.pregenIdentifierType &&
            !!this.userId &&
            wallet.userId === this.userId);
    }
    isPregenWalletUnclaimed(wallet) {
        return (this.isWalletSupported(wallet) &&
            (!wallet.userId || (wallet.isPregen && !!wallet.pregenIdentifier && !!wallet.pregenIdentifierType)));
    }
    isPregenWalletClaimable(wallet) {
        return (this.isWalletSupported(wallet) &&
            this.isPregenWalletUnclaimed(wallet) &&
            (!['EMAIL', 'PHONE', 'TELEGRAM'].includes(wallet.pregenIdentifierType) ||
                (0, index_js_2.isPregenIdentifierMatch)(wallet.pregenIdentifierType === 'EMAIL'
                    ? this.email
                    : wallet.pregenIdentifierType === 'TELEGRAM'
                        ? this.telegramUserId
                        : this.getPhoneNumber(), wallet.pregenIdentifier, wallet.pregenIdentifierType)));
    }
    isWalletUsable(walletId, { type: types, scheme: schemes, forbidPregen = false } = {}, throwError = false) {
        let error;
        if (!this.wallets[walletId]) {
            error = `wallet with id ${walletId} does not exist`;
        }
        else {
            const wallet = this.wallets[walletId];
            const [isUnclaimed, isOwned] = [this.isPregenWalletUnclaimed(wallet), this.isWalletOwned(wallet)];
            if (forbidPregen && isUnclaimed) {
                error = `pre-generated wallet with id ${wallet.id} cannot be selected`;
            }
            else if (!isOwned && !isUnclaimed) {
                error = `wallet with id ${wallet.id} is not owned by the current user`;
            }
            else if (!this.isWalletSupported(wallet)) {
                error = `wallet with id ${wallet.id} and type ${wallet.type} is not supported, supported types are: ${this.supportedWalletTypes.map(({ type }) => type).join(', ')}`;
            }
            else if (types &&
                (!(0, index_js_2.getEquivalentTypes)(types).includes(wallet.type) ||
                    (isOwned && !types.some(type => { var _a; return ((_a = this.currentWalletIds[type]) !== null && _a !== void 0 ? _a : []).includes(walletId); })))) {
                error = `wallet with id ${wallet.id} and type ${wallet.type} cannot be selected`;
            }
            else if (schemes && !schemes.includes(wallet.scheme)) {
                error = `wallet with id ${wallet.id} and scheme ${wallet.scheme} cannot be selected`;
            }
        }
        if (error) {
            if (throwError) {
                throw new Error(error);
            }
            return false;
        }
        return true;
    }
    /**
     * Returns the formatted address for the desired wallet ID, depending on your app settings.
     * @param {string} walletId the ID of the wallet address to display.
     * @param {object} options additional options for formatting the address.
     * @param {boolean} options.truncate whether to truncate the address.
     * @param {WalletType} options.addressType the type of address to display.
     * @returns the formatted address
     */
    getDisplayAddress(walletId, options = {}) {
        var _a;
        if (this.externalWallets[walletId]) {
            const wallet = this.externalWallets[walletId];
            return options.truncate ? (0, index_js_2.truncateAddress)(wallet.address, wallet.type, { prefix: this.cosmosPrefix }) : wallet.address;
        }
        const wallet = this.findWallet(walletId, options.addressType);
        if (!wallet) {
            return undefined;
        }
        let str;
        switch (wallet.type) {
            case user_management_client_1.WalletType.COSMOS:
                str = (0, index_js_2.getCosmosAddress)(wallet.publicKey, (_a = this.cosmosPrefix) !== null && _a !== void 0 ? _a : 'cosmos');
                break;
            default:
                str = wallet.address;
                break;
        }
        return options.truncate ? (0, index_js_2.truncateAddress)(str, wallet.type, { prefix: this.cosmosPrefix }) : str;
    }
    /**
     * Returns a unique hash for a wallet suitable for use as an identicon seed.
     * @param {string} walletId the ID of the wallet.
     * @param {boolean} options.addressType used to format the hash for another wallet type.
     * @returns the identicon hash string
     */
    getIdenticonHash(walletId, overrideType) {
        if (this.externalWallets[walletId]) {
            const wallet = this.externalWallets[walletId];
            return `${wallet.id}-${wallet.address}-${wallet.type}`;
        }
        const wallet = this.findWallet(walletId, overrideType);
        return wallet ? `${wallet.id}-${wallet.address}-${wallet.type}` : undefined;
    }
    getWallets() {
        return this.wallets;
    }
    getAddress(walletId) {
        var _a, _b;
        return walletId ? this.wallets[walletId].address : (_b = (_a = Object.values(this.wallets)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.address;
    }
    constructPortalUrl(type, opts = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        return __awaiter(this, void 0, void 0, function* () {
            const base = type === 'onRamp' ? (0, index_js_2.getPortalBaseURL)(this.ctx) : yield this.getPortalURL(opts.partnerId);
            let path;
            switch (type) {
                case 'createPassword': {
                    path = `/web/users/${this.userId}/passwords/${opts.pathId}`;
                    break;
                }
                case 'createAuth': {
                    path = `/web/users/${this.userId}/biometrics/${opts.pathId}`;
                    break;
                }
                case 'loginPassword': {
                    path = '/web/passwords/login';
                    break;
                }
                case 'loginAuth': {
                    path = '/web/biometrics/login';
                    break;
                }
                case 'txReview': {
                    path = `/web/users/${this.userId}/transaction-review/${opts.pathId}`;
                    break;
                }
                case 'onRamp': {
                    path = `/web/users/${this.userId}/on-ramp-transaction/${opts.pathId}`;
                    break;
                }
                default: {
                    throw new Error(`invalid URL type ${type}`);
                }
            }
            const [isCreate, isLogin, isOnRamp] = [
                ['createAuth', 'createPassword'].includes(type),
                ['loginAuth', 'loginPassword'].includes(type),
                type === 'onRamp',
            ];
            const partner = opts.partnerId
                ? (_a = (yield this.ctx.client.getPartner(opts.partnerId)).data) === null || _a === void 0 ? void 0 : _a.partner
                : undefined;
            const params = Object.assign(Object.assign(Object.assign(Object.assign({ apiKey: this.ctx.apiKey, partnerId: opts.partnerId, portalFont: ((_b = opts.theme) === null || _b === void 0 ? void 0 : _b.font) || (partner === null || partner === void 0 ? void 0 : partner.font) || ((_c = this.portalTheme) === null || _c === void 0 ? void 0 : _c.font), portalBorderRadius: ((_d = opts.theme) === null || _d === void 0 ? void 0 : _d.borderRadius) || ((_e = this.portalTheme) === null || _e === void 0 ? void 0 : _e.borderRadius), portalThemeMode: ((_f = opts.theme) === null || _f === void 0 ? void 0 : _f.mode) || (partner === null || partner === void 0 ? void 0 : partner.themeMode) || ((_g = this.portalTheme) === null || _g === void 0 ? void 0 : _g.mode), portalAccentColor: ((_h = opts.theme) === null || _h === void 0 ? void 0 : _h.accentColor) || (partner === null || partner === void 0 ? void 0 : partner.accentColor) || ((_j = this.portalTheme) === null || _j === void 0 ? void 0 : _j.accentColor), portalForegroundColor: ((_k = opts.theme) === null || _k === void 0 ? void 0 : _k.foregroundColor) || (partner === null || partner === void 0 ? void 0 : partner.foregroundColor) || ((_l = this.portalTheme) === null || _l === void 0 ? void 0 : _l.foregroundColor), portalBackgroundColor: ((_m = opts.theme) === null || _m === void 0 ? void 0 : _m.backgroundColor) ||
                    (partner === null || partner === void 0 ? void 0 : partner.backgroundColor) ||
                    this.portalBackgroundColor ||
                    ((_o = this.portalTheme) === null || _o === void 0 ? void 0 : _o.backgroundColor), portalPrimaryButtonColor: this.portalPrimaryButtonColor, portalTextColor: this.portalTextColor, portalPrimaryButtonTextColor: this.portalPrimaryButtonTextColor, isForNewDevice: opts.isForNewDevice ? opts.isForNewDevice.toString() : undefined, supportedWalletTypes: __classPrivateFieldGet(this, _ParaCore_supportedWalletTypesOpt, "f") ? JSON.stringify(__classPrivateFieldGet(this, _ParaCore_supportedWalletTypesOpt, "f")) : undefined }, (isCreate || isLogin
                ? Object.assign(Object.assign(Object.assign(Object.assign({}, (opts.authType === 'email' ? { email: this.email } : {})), (opts.authType === 'phone' ? { phone: this.phone, countryCode: this.countryCode } : {})), (opts.authType === 'farcaster' ? { farcasterUsername: this.farcasterUsername } : {})), (opts.authType === 'telegram' ? { telegramUserId: this.telegramUserId } : {})) : {})), (isLogin || isOnRamp ? { sessionId: opts.sessionId } : {})), (isLogin
                ? {
                    encryptionKey: opts.loginEncryptionPublicKey,
                    newDeviceSessionLookupId: opts.newDeviceSessionId,
                    newDeviceEncryptionKey: opts.newDeviceEncryptionKey,
                    pregenIds: JSON.stringify(this.pregenIds),
                    displayName: opts.displayName,
                    pfpUrl: opts.pfpUrl,
                }
                : {})), (opts.params || {}));
            return (0, index_js_2.constructUrl)({ base, path, params });
        });
    }
    /**
     * Constructs a new `ParaCore` instance.
     * @param env - `Environment` to use.
     * @param apiKey - API key to use.
     * @param opts - Additional constructor options; see `ConstructorOpts`.
     * @returns - A new ParaCore instance.
     */
    constructor(env, apiKey, opts) {
        var _a;
        this.isAwaitingAccountCreation = false;
        this.isAwaitingLogin = false;
        this.isAwaitingFarcaster = false;
        this.isAwaitingOAuth = false;
        /**
         * The IDs of the currently active wallets, for each supported wallet type. Any signer integrations will default to the first viable wallet ID in this dictionary.
         */
        this.currentWalletIds = {};
        _ParaCore_supportedWalletTypes.set(this, undefined);
        _ParaCore_supportedWalletTypesOpt.set(this, undefined);
        this.localStorageGetItem = (key) => {
            return this.platformUtils.localStorage.get(key);
        };
        this.localStorageSetItem = (key, value) => {
            return this.platformUtils.localStorage.set(key, value);
        };
        this.sessionStorageGetItem = (key) => {
            return this.platformUtils.sessionStorage.get(key);
        };
        this.sessionStorageSetItem = (key, value) => {
            return this.platformUtils.sessionStorage.set(key, value);
        };
        this.sessionStorageRemoveItem = (key) => {
            return this.platformUtils.sessionStorage.removeItem(key);
        };
        this.retrieveSessionCookie = () => {
            return this.sessionCookie;
        };
        /**
         * Remove all local storage and prefixed session storage.
         * @param {'local' | 'session' | 'secure' | 'all'} type - Type of storage to clear. Defaults to 'all'.
         */
        this.clearStorage = (type = 'all') => __awaiter(this, void 0, void 0, function* () {
            const isAll = type === 'all';
            (isAll || type === 'local') && this.platformUtils.localStorage.clear(constants.PREFIX);
            (isAll || type === 'session') && this.platformUtils.sessionStorage.clear(constants.PREFIX);
            if ((isAll || type === 'secure') && this.platformUtils.secureStorage) {
                this.platformUtils.secureStorage.clear(constants.PREFIX);
            }
        });
        /**
         * Creates several new wallets with the desired types. If no types are provided, this method
         * will create one for each of the non-optional types specified in the instance's `supportedWalletTypes`
         * object that are not already present. This is automatically called upon account creation to ensure that
         * the user has a wallet of each required type.
         *
         * @deprecated alias for `createWalletPerType`
         **/
        this.createWalletPerMissingType = this.createWalletPerType;
        // TODO: consider using sessionStorage instead of localStorage
        if (!opts)
            opts = {};
        this.emailPrimaryColor = opts.emailPrimaryColor;
        this.emailTheme = opts.emailTheme;
        this.homepageUrl = opts.homepageUrl;
        this.supportUrl = opts.supportUrl;
        this.xUrl = opts.xUrl;
        this.githubUrl = opts.githubUrl;
        this.linkedinUrl = opts.linkedinUrl;
        this.portalBackgroundColor = opts.portalBackgroundColor;
        this.portalPrimaryButtonColor = opts.portalPrimaryButtonColor;
        this.portalTextColor = opts.portalTextColor;
        this.portalPrimaryButtonTextColor = opts.portalPrimaryButtonTextColor;
        this.portalTheme = opts.portalTheme;
        this.platformUtils = this.getPlatformUtils();
        this.disableProviderModal = this.platformUtils.disableProviderModal;
        if (opts.useStorageOverrides) {
            this.localStorageGetItem = opts.localStorageGetItemOverride;
            this.localStorageSetItem = opts.localStorageSetItemOverride;
            this.sessionStorageGetItem = opts.sessionStorageGetItemOverride;
            this.sessionStorageSetItem = opts.sessionStorageSetItemOverride;
            this.sessionStorageRemoveItem = opts.sessionStorageRemoveItemOverride;
            this.clearStorage = opts.clearStorageOverride;
        }
        if (opts.useSessionStorage) {
            this.localStorageGetItem = this.sessionStorageGetItem;
            this.localStorageSetItem = this.sessionStorageSetItem;
        }
        this.persistSessionCookie = (cookie) => {
            this.sessionCookie = cookie;
            (opts.useSessionStorage ? this.sessionStorageSetItem : this.localStorageSetItem)(constants.LOCAL_STORAGE_SESSION_COOKIE, cookie);
        };
        this.ctx = {
            env,
            apiKey,
            client: (0, userManagementClient_js_1.initClient)({
                env,
                version: ParaCore.version,
                apiKey,
                partnerId: this.isPortal(env) ? opts.portalPartnerId : undefined,
                useFetchAdapter: !!opts.disableWorkers,
                retrieveSessionCookie: this.retrieveSessionCookie,
                persistSessionCookie: this.persistSessionCookie,
            }),
            disableWorkers: opts.disableWorkers,
            offloadMPCComputationURL: opts.offloadMPCComputationURL,
            useLocalFiles: opts.useLocalFiles,
            useDKLS: opts.useDKLSForCreation || !opts.offloadMPCComputationURL,
            disableWebSockets: !!opts.disableWebSockets,
            wasmOverride: opts.wasmOverride,
            cosmosPrefix: this.cosmosPrefix,
        };
        if (opts.offloadMPCComputationURL) {
            this.ctx.mpcComputationClient = mpcComputationClient.initClient(opts.offloadMPCComputationURL, opts.disableWorkers);
        }
        // Support legacy supportedWalletTypes
        try {
            __classPrivateFieldSet(this, _ParaCore_supportedWalletTypes, opts.supportedWalletTypes
                ? (() => {
                    if (Object.values(opts.supportedWalletTypes).every(config => !!config && typeof config === 'object' && config.optional)) {
                        throw new Error('at least one wallet type must be non-optional');
                    }
                    if (!Object.keys(opts.supportedWalletTypes).every(type => Object.values(user_management_client_1.WalletType).includes(type))) {
                        throw new Error('unsupported wallet type');
                    }
                    __classPrivateFieldSet(this, _ParaCore_supportedWalletTypesOpt, opts.supportedWalletTypes, "f");
                    return Object.entries(opts.supportedWalletTypes).reduce((acc, [key, value]) => {
                        var _a;
                        if (!value) {
                            return acc;
                        }
                        if (key === user_management_client_1.WalletType.COSMOS &&
                            typeof value === 'object' &&
                            !!value.prefix) {
                            this.cosmosPrefix = value.prefix;
                        }
                        return [...acc, { type: key, optional: value === true ? false : ((_a = value.optional) !== null && _a !== void 0 ? _a : false) }];
                    }, []);
                })()
                : undefined, "f");
        }
        catch (e) {
            __classPrivateFieldSet(this, _ParaCore_supportedWalletTypes, undefined, "f");
        }
        if (!this.platformUtils.isSyncStorage || opts.useStorageOverrides) {
            return;
        }
        this.email = this.localStorageGetItem(constants.LOCAL_STORAGE_EMAIL) || undefined;
        this.countryCode = this.localStorageGetItem(constants.LOCAL_STORAGE_COUNTRY_CODE) || undefined;
        this.phone = this.localStorageGetItem(constants.LOCAL_STORAGE_PHONE) || undefined;
        this.userId = this.localStorageGetItem(constants.LOCAL_STORAGE_USER_ID) || undefined;
        this.telegramUserId = this.localStorageGetItem(constants.LOCAL_STORAGE_TELEGRAM_USER_ID) || undefined;
        const stringWallets = this.platformUtils.secureStorage
            ? this.platformUtils.secureStorage.get(constants.LOCAL_STORAGE_WALLETS)
            : this.localStorageGetItem(constants.LOCAL_STORAGE_WALLETS);
        const _wallets = JSON.parse(stringWallets || '{}');
        const stringEd25519Wallets = this.platformUtils.secureStorage
            ? this.platformUtils.secureStorage.get(constants.LOCAL_STORAGE_ED25519_WALLETS)
            : this.localStorageGetItem(constants.LOCAL_STORAGE_ED25519_WALLETS);
        const _ed25519Wallets = JSON.parse(stringEd25519Wallets || '{}');
        const wallets = Object.assign(Object.assign({}, Object.keys(_wallets).reduce((res, key) => {
            return Object.assign(Object.assign({}, res), { [key]: (0, index_js_2.migrateWallet)(_wallets[key]) });
        }, {})), Object.keys(_ed25519Wallets).reduce((res, key) => {
            return Object.assign(Object.assign({}, res), (!res[key] ? { [key]: (0, index_js_2.migrateWallet)(_ed25519Wallets[key]) } : {}));
        }, {}));
        this.setWallets(wallets);
        // TODO: Improve not great check
        const _currentWalletIds = (_a = this.localStorageGetItem(constants.LOCAL_STORAGE_CURRENT_WALLET_IDS)) !== null && _a !== void 0 ? _a : undefined;
        const currentWalletIds = [undefined, null, 'undefined'].includes(_currentWalletIds)
            ? {}
            : (() => {
                const fromJson = JSON.parse(_currentWalletIds);
                return Array.isArray(fromJson)
                    ? Object.keys(user_management_client_1.WalletType).reduce((acc, type) => {
                        const wallet = Object.values(this.wallets).find(w => fromJson.includes(w.id) && index_js_2.WalletSchemeTypeMap[w.scheme][type]);
                        return Object.assign(Object.assign({}, acc), (wallet && !acc[type] ? { [type]: [wallet.id] } : {}));
                    }, {})
                    : fromJson;
            })();
        this.setCurrentWalletIds(currentWalletIds);
        // TODO: remove sessionStorageGetItem call once new version is being consumed
        this.sessionCookie =
            this.localStorageGetItem(constants.LOCAL_STORAGE_SESSION_COOKIE) ||
                this.sessionStorageGetItem(constants.LOCAL_STORAGE_SESSION_COOKIE) ||
                undefined;
        // In case currentWalletIds was missing from storage
        if (Object.values(this.wallets).filter(w => this.isWalletOwned(w)).length > 0 &&
            this.currentWalletIdsArray.length === 0) {
            this.findWalletId(undefined, { forbidPregen: true });
        }
        const loginEncryptionKey = this.sessionStorageGetItem(constants.SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR);
        if (loginEncryptionKey && loginEncryptionKey !== 'undefined') {
            this.loginEncryptionKeyPair = this.convertEncryptionKeyPair(JSON.parse(loginEncryptionKey));
        }
        const stringExternalWallets = this.localStorageGetItem(constants.LOCAL_STORAGE_EXTERNAL_WALLETS);
        const _externalWallets = JSON.parse(stringExternalWallets || '{}');
        this.setExternalWallets(_externalWallets);
        const _currentExternalWalletAddresses = this.localStorageGetItem(constants.LOCAL_STORAGE_CURRENT_EXTERNAL_WALLET_ADDRESSES) || undefined;
        this.currentExternalWalletAddresses = _currentExternalWalletAddresses
            ? JSON.parse(_currentExternalWalletAddresses)
            : undefined;
    }
    touchSession(regenerate = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.client.touchSession(regenerate);
            this.setSupportedWalletTypes(res.data.supportedWalletTypes, res.data.cosmosPrefix);
            return res;
        });
    }
    setSupportedWalletTypes(supportedWalletTypes, cosmosPrefix) {
        if (supportedWalletTypes && !__classPrivateFieldGet(this, _ParaCore_supportedWalletTypes, "f")) {
            __classPrivateFieldSet(this, _ParaCore_supportedWalletTypes, supportedWalletTypes, "f");
            Object.keys(this.currentWalletIds).forEach((type) => {
                var _a;
                if (!((_a = __classPrivateFieldGet(this, _ParaCore_supportedWalletTypes, "f")) === null || _a === void 0 ? void 0 : _a.some(({ type: supportedType }) => supportedType === type))) {
                    delete this.currentWalletIds[type];
                }
            });
        }
        if (cosmosPrefix && !this.cosmosPrefix) {
            this.cosmosPrefix = cosmosPrefix;
        }
    }
    getVerificationEmailProps() {
        return {
            brandColor: this.emailPrimaryColor,
            theme: this.emailTheme,
            supportUrl: this.supportUrl,
            homepageUrl: this.homepageUrl,
            xUrl: this.xUrl,
            githubUrl: this.githubUrl,
            linkedinUrl: this.linkedinUrl,
        };
    }
    getBackupKitEmailProps() {
        return {
            brandColor: this.emailPrimaryColor,
            theme: this.emailTheme,
            homepageUrl: this.homepageUrl,
            xUrl: this.xUrl,
            linkedinUrl: this.linkedinUrl,
            githubUrl: this.githubUrl,
            supportUrl: this.supportUrl,
        };
    }
    /**
     * Initialize storage relating to a `ParaCore` instance.
     *
     * Init only needs to be called for storage that is async.
     */
    init() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.email = (yield this.localStorageGetItem(constants.LOCAL_STORAGE_EMAIL)) || undefined;
            this.countryCode =
                (yield this.localStorageGetItem(constants.LOCAL_STORAGE_COUNTRY_CODE)) || undefined;
            this.phone = (yield this.localStorageGetItem(constants.LOCAL_STORAGE_PHONE)) || undefined;
            this.userId = (yield this.localStorageGetItem(constants.LOCAL_STORAGE_USER_ID)) || undefined;
            this.telegramUserId =
                (yield this.localStorageGetItem(constants.LOCAL_STORAGE_TELEGRAM_USER_ID)) || undefined;
            const stringWallets = this.platformUtils.secureStorage
                ? yield this.platformUtils.secureStorage.get(constants.LOCAL_STORAGE_WALLETS)
                : yield this.localStorageGetItem(constants.LOCAL_STORAGE_WALLETS);
            const _wallets = JSON.parse(stringWallets || '{}');
            const stringEd25519Wallets = this.platformUtils.secureStorage
                ? yield this.platformUtils.secureStorage.get(constants.LOCAL_STORAGE_ED25519_WALLETS)
                : yield this.localStorageGetItem(constants.LOCAL_STORAGE_ED25519_WALLETS);
            const _ed25519Wallets = JSON.parse(stringEd25519Wallets || '{}');
            const wallets = Object.assign(Object.assign({}, Object.keys(_wallets).reduce((res, key) => {
                return Object.assign(Object.assign({}, res), { [key]: (0, index_js_2.migrateWallet)(_wallets[key]) });
            }, {})), Object.keys(_ed25519Wallets).reduce((res, key) => {
                return Object.assign(Object.assign({}, res), (!res[key] ? { [key]: (0, index_js_2.migrateWallet)(_ed25519Wallets[key]) } : {}));
            }, {}));
            yield this.setWallets(wallets);
            // TODO: Improve not great check
            const _currentWalletIds = (_a = (yield this.localStorageGetItem(constants.LOCAL_STORAGE_CURRENT_WALLET_IDS))) !== null && _a !== void 0 ? _a : undefined;
            const currentWalletIds = [undefined, null, 'undefined', 'null'].includes(_currentWalletIds)
                ? {}
                : (() => {
                    const fromJson = JSON.parse(_currentWalletIds);
                    return Array.isArray(fromJson)
                        ? Object.keys(user_management_client_1.WalletType).reduce((acc, type) => {
                            const wallet = Object.values(this.wallets).find(w => fromJson.includes(w.id) && index_js_2.WalletSchemeTypeMap[w.scheme][type]);
                            return Object.assign(Object.assign({}, acc), (wallet && !acc[type] ? { [type]: [wallet.id] } : {}));
                        }, {})
                        : fromJson;
                })();
            yield this.setCurrentWalletIds(currentWalletIds);
            // TODO: remove sessionStorageGetItem call once new version is being consumed
            this.sessionCookie =
                (yield this.localStorageGetItem(constants.LOCAL_STORAGE_SESSION_COOKIE)) ||
                    (yield this.sessionStorageGetItem(constants.LOCAL_STORAGE_SESSION_COOKIE)) ||
                    undefined;
            // In case currentWalletIds was missing from storage
            if (Object.values(this.wallets).filter(w => this.isWalletOwned(w)).length > 0 &&
                this.currentWalletIdsArray.length === 0) {
                this.findWalletId(undefined, { forbidPregen: true });
            }
            const loginEncryptionKey = (yield this.sessionStorageGetItem(constants.SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR));
            if (loginEncryptionKey && loginEncryptionKey !== 'undefined') {
                this.loginEncryptionKeyPair = this.convertEncryptionKeyPair(JSON.parse(loginEncryptionKey));
            }
            const stringExternalWallets = yield this.localStorageGetItem(constants.LOCAL_STORAGE_EXTERNAL_WALLETS);
            const _externalWallets = JSON.parse(stringExternalWallets || '{}');
            yield this.setExternalWallets(_externalWallets);
            const _currentExternalWalletAddresses = (yield this.localStorageGetItem(constants.LOCAL_STORAGE_CURRENT_EXTERNAL_WALLET_ADDRESSES)) || undefined;
            this.currentExternalWalletAddresses = _currentExternalWalletAddresses
                ? JSON.parse(_currentExternalWalletAddresses)
                : undefined;
            yield this.touchSession();
        });
    }
    /**
     * Sets the email associated with the `ParaCore` instance.
     * @param email - Email to set.
     */
    setEmail(email) {
        return __awaiter(this, void 0, void 0, function* () {
            this.email = email;
            yield this.localStorageSetItem(constants.LOCAL_STORAGE_EMAIL, email);
        });
    }
    /**
     * Sets the Telegram user ID associated with the `ParaCore` instance.
     * @param telegramUserId - Telegram user ID to set.
     */
    setTelegramUserId(telegramUserId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.telegramUserId = telegramUserId;
            yield this.localStorageSetItem(constants.LOCAL_STORAGE_TELEGRAM_USER_ID, telegramUserId);
        });
    }
    /**
     * Sets the phone number associated with the `ParaCore` instance.
     * @param phone - Phone number to set.
     * @param countryCode - Country Code to set.
     */
    setPhoneNumber(phone, countryCode) {
        return __awaiter(this, void 0, void 0, function* () {
            this.phone = phone;
            this.countryCode = countryCode;
            yield this.localStorageSetItem(constants.LOCAL_STORAGE_PHONE, phone);
            yield this.localStorageSetItem(constants.LOCAL_STORAGE_COUNTRY_CODE, countryCode);
        });
    }
    /**
     * Sets the farcaster username associated with the `ParaCore` instance.
     * @param farcasterUsername - Farcaster Username to set.
     */
    setFarcasterUsername(farcasterUsername) {
        return __awaiter(this, void 0, void 0, function* () {
            this.farcasterUsername = farcasterUsername;
            yield this.localStorageSetItem(constants.LOCAL_STORAGE_FARCASTER_USERNAME, farcasterUsername);
        });
    }
    /**
     * Sets the external wallet address and type associated with the `ParaCore` instance.
     * @param externalAddress - External wallet address to set.
     * @param externalType - Type of external wallet to set.
     */
    setExternalWallet({ address, type, provider, addressBech32 }) {
        return __awaiter(this, void 0, void 0, function* () {
            // Can change this to continue storing existing external wallets if/when we want to allow multiple connected external wallets
            this.externalWallets = {
                [address]: {
                    id: address,
                    address: addressBech32 !== null && addressBech32 !== void 0 ? addressBech32 : address,
                    type,
                    name: provider,
                    isExternal: true,
                    signer: '',
                },
            };
            this.currentExternalWalletAddresses = [address];
            this.setCurrentExternalWalletAddresses(this.currentExternalWalletAddresses);
            this.setExternalWallets(this.externalWallets);
            (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.EXTERNAL_WALLET_CHANGE_EVENT, null);
        });
    }
    /**
     * Sets the user id associated with the `ParaCore` instance.
     * @param userId - User id to set.
     */
    setUserId(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.userId = userId;
            yield this.localStorageSetItem(constants.LOCAL_STORAGE_USER_ID, userId);
        });
    }
    /**
     * Sets the wallets associated with the `ParaCore` instance.
     * @param wallets - Wallets to set.
     */
    setWallets(wallets) {
        return __awaiter(this, void 0, void 0, function* () {
            this.wallets = wallets;
            if (this.platformUtils.secureStorage) {
                yield this.platformUtils.secureStorage.set(constants.LOCAL_STORAGE_WALLETS, JSON.stringify(wallets));
                return;
            }
            yield this.localStorageSetItem(constants.LOCAL_STORAGE_WALLETS, JSON.stringify(wallets));
        });
    }
    /**
     * Sets the external wallets associated with the `ParaCore` instance.
     * @param externalWallets - External wallets to set.
     */
    setExternalWallets(externalWallets) {
        return __awaiter(this, void 0, void 0, function* () {
            this.externalWallets = externalWallets;
            yield this.localStorageSetItem(constants.LOCAL_STORAGE_EXTERNAL_WALLETS, JSON.stringify(externalWallets));
        });
    }
    setCurrentExternalWalletAddresses(currentExternalWalletAddresses) {
        return __awaiter(this, void 0, void 0, function* () {
            this.currentExternalWalletAddresses = currentExternalWalletAddresses;
            yield this.localStorageSetItem(constants.LOCAL_STORAGE_CURRENT_EXTERNAL_WALLET_ADDRESSES, JSON.stringify(currentExternalWalletAddresses));
        });
    }
    /**
     * Sets the login encryption key pair associated with the `ParaCore` instance.
     * @param keyPair - Encryption key pair generated from loginEncryptionKey.
     */
    setLoginEncryptionKeyPair(keyPair) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!keyPair) {
                keyPair = yield (0, utils_js_1.getAsymmetricKeyPair)(this.ctx);
            }
            this.loginEncryptionKeyPair = keyPair;
            yield this.sessionStorageSetItem(constants.SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR, JSON.stringify(keyPair));
        });
    }
    deleteLoginEncryptionKeyPair() {
        return __awaiter(this, void 0, void 0, function* () {
            this.loginEncryptionKeyPair = undefined;
            yield this.sessionStorageRemoveItem(constants.SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR);
        });
    }
    /**
     * Gets the userId associated with the `ParaCore` instance.
     * @returns - userId associated with the `ParaCore` instance.
     */
    getUserId() {
        return this.userId;
    }
    /**
     * Gets the email associated with the `ParaCore` instance.
     * @returns - email associated with the `ParaCore` instance.
     */
    getEmail() {
        return this.email;
    }
    /**
     * Gets the phone object associated with the `ParaCore` instance.
     * @returns - phone object with phone number and country code associated with the `ParaCore` instance.
     */
    getPhone() {
        return { phone: this.phone, countryCode: this.countryCode };
    }
    /**
     * Gets the formatted phone number associated with the `ParaCore` instance.
     * @returns - formatted phone number associated with the `ParaCore` instance.
     */
    getPhoneNumber() {
        if (!this.phone || !this.countryCode) {
            return undefined;
        }
        return (0, index_js_2.normalizePhoneNumber)(this.countryCode, this.phone);
    }
    /**
     * Gets the farcaster username associated with the `ParaCore` instance.
     * @returns - farcaster username associated with the `ParaCore` instance.
     */
    getFarcasterUsername() {
        return this.farcasterUsername;
    }
    setCurrentWalletIds(currentWalletIds, { needsWallet = false, sessionLookupId, newDeviceSessionLookupId, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.currentWalletIds = currentWalletIds;
            yield this.localStorageSetItem(constants.LOCAL_STORAGE_CURRENT_WALLET_IDS, JSON.stringify(this.currentWalletIds));
            if (sessionLookupId) {
                yield this.ctx.client.setCurrentWalletIds(this.getUserId(), this.currentWalletIds, needsWallet, sessionLookupId, newDeviceSessionLookupId);
            }
            (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.WALLETS_CHANGE_EVENT, null);
        });
    }
    /**
     * Validates that a wallet ID is present on the instance, usable, and matches the desired filters.
     * If no ID is passed, this will instead return the first valid, usable wallet ID that matches the filters.
     * @param {string} [walletId] the wallet ID to validate.
     * @param {WalletFilters} [filter={}] a `WalletFilters` object specifying allowed types, schemes, and whether to forbid unclaimed pregen wallets.
     * @returns {string} the wallet ID originally passed, or the one found.
     */
    findWalletId(walletId, filter = {}) {
        if (walletId) {
            this.assertIsValidWalletId(walletId, filter);
        }
        else {
            for (const id of [...this.currentWalletIdsUnique, ...Object.keys(this.wallets)]) {
                if (this.isWalletUsable(id, filter)) {
                    walletId = id;
                    break;
                }
            }
            if (!walletId) {
                throw new Error(`no valid wallet id found`);
            }
        }
        return walletId;
    }
    /**
     * Retrieves a wallet with the given address, if present.
     * If no ID is passed, this will instead return the first valid, usable wallet ID that matches the filters.
     * @param {string} [walletId] the wallet ID to validate.
     * @param {WalletFilters} [filter={}] a `WalletFilters` object specifying allowed types, schemes, and whether to forbid unclaimed pregen wallets.
     * @returns {string} the wallet ID originally passed, or the one found.
     */
    findWalletByAddress(address, filter) {
        if (this.externalWallets[address]) {
            return this.externalWallets[address];
        }
        let wallet;
        Object.entries(this.currentWalletIds).forEach(([type, walletIds]) => {
            const pregenWalletIds = Object.keys(this.wallets).filter(id => this.wallets[id].type === type && this.isPregenWalletClaimable(this.wallets[id]));
            [...walletIds, ...pregenWalletIds].forEach(id => {
                if (address.toLowerCase() === this.getDisplayAddress(id, { addressType: type }).toLowerCase()) {
                    wallet = this.wallets[id];
                }
            });
        });
        if (!wallet) {
            throw new Error(`wallet with address ${address} not found`);
        }
        this.assertIsValidWalletId(wallet.id, filter);
        return wallet;
    }
    findWallet(idOrAddress, overrideType, filter = {}) {
        var _a, _b;
        if (!idOrAddress && Object.keys(this.externalWallets).length > 0) {
            return Object.values(this.externalWallets)[0];
        }
        if (this.externalWallets[idOrAddress]) {
            return this.externalWallets[idOrAddress];
        }
        try {
            const walletId = this.findWalletId(idOrAddress, filter);
            if (walletId && !!this.wallets[walletId]) {
                const _c = this.wallets[walletId], { signer: _signer } = _c, wallet = __rest(_c, ["signer"]);
                const type = (_b = overrideType !== null && overrideType !== void 0 ? overrideType : (_a = this.currentWalletIdsArray.find(([id]) => id === walletId)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : wallet.type;
                return Object.assign(Object.assign({}, wallet), { type: user_management_client_1.WalletType[type] });
            }
        }
        catch (e) {
            return undefined;
        }
    }
    get availableWallets() {
        var _a;
        return [
            ...this.currentWalletIdsArray
                .map(([address, type]) => [address, type, false])
                .map(([id, type]) => {
                const wallet = this.findWallet(id, type);
                if (!wallet)
                    return null;
                return {
                    id: wallet.id,
                    type,
                    address: this.getDisplayAddress(id, { addressType: type }),
                    name: wallet.name,
                };
            })
                .filter(obj => obj !== null),
            ...Object.values((_a = this.externalWallets) !== null && _a !== void 0 ? _a : {}),
        ];
    }
    /**
     * Retrieves all usable wallets with the provided type (`'EVM' | 'COSMOS' | 'SOLANA'`)
     * @param {string} type the wallet type to filter by.
     * @returns {Wallet[]} an array of matching wallets.
     */
    getWalletsByType(type) {
        return Object.values(this.wallets).filter(w => this.isWalletUsable(w.id, { type: [type] }));
    }
    assertIsValidWalletId(walletId, condition = {}) {
        this.isWalletUsable(walletId, condition, true);
    }
    assertIsValidWalletType(type, walletTypes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!__classPrivateFieldGet(this, _ParaCore_supportedWalletTypes, "f")) {
                yield this.touchSession();
            }
            if (!type ||
                !Object.values(user_management_client_1.WalletType).includes(type) ||
                !(walletTypes !== null && walletTypes !== void 0 ? walletTypes : this.supportedWalletTypes.map(({ type }) => type)).includes(type)) {
                throw new Error(`wallet type ${type} is not supported`);
            }
            return type;
        });
    }
    getMissingTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!__classPrivateFieldGet(this, _ParaCore_supportedWalletTypes, "f")) {
                yield this.touchSession();
            }
            return (this.supportedWalletTypes
                .filter(({ type: t, optional }) => !optional && Object.values(this.wallets).every(w => !this.isWalletOwned(w) || !index_js_2.WalletSchemeTypeMap[w.scheme][t]))
                .map(({ type }) => type));
        });
    }
    getTypesToCreate(types) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!__classPrivateFieldGet(this, _ParaCore_supportedWalletTypes, "f")) {
                yield this.touchSession();
            }
            return (0, index_js_2.getSchemes)(types !== null && types !== void 0 ? types : (yield this.getMissingTypes())).map(scheme => {
                switch (scheme) {
                    case user_management_client_1.WalletScheme.ED25519:
                        return user_management_client_1.WalletType.SOLANA;
                    default:
                        return this.supportedWalletTypes.some(({ type, optional }) => type === user_management_client_1.WalletType.COSMOS && !optional)
                            ? user_management_client_1.WalletType.COSMOS
                            : user_management_client_1.WalletType.EVM;
                }
            });
        });
    }
    getPartnerURL(partnerId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.client.getPartner(partnerId);
            return res.data.partner.portalUrl;
        });
    }
    /**
     * URL of the portal, which can be associated with a partner id
     * @param partnerId: string - id of the partner to get the portal URL for
     * @returns - portal URL
     */
    getPortalURL(partnerId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (partnerId && (yield this.getPartnerURL(partnerId))) || (0, index_js_2.getPortalBaseURL)(this.ctx);
        });
    }
    getWebAuthURLForCreate(_a) {
        var { webAuthId } = _a, options = __rest(_a, ["webAuthId"]);
        return __awaiter(this, void 0, void 0, function* () {
            return this.constructPortalUrl('createAuth', Object.assign(Object.assign({}, options), { pathId: webAuthId }));
        });
    }
    getPasswordURLForCreate(_a) {
        var { passwordId } = _a, options = __rest(_a, ["passwordId"]);
        return __awaiter(this, void 0, void 0, function* () {
            return this.constructPortalUrl('createPassword', Object.assign(Object.assign({}, options), { pathId: passwordId }));
        });
    }
    getShortUrl(compressedUrl) {
        return (0, index_js_2.constructUrl)({
            base: (0, index_js_2.getPortalBaseURL)(this.ctx),
            path: `/short/${compressedUrl}`,
        });
    }
    shortenLoginLink(link) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield transmissionUtils.upload(link, this.ctx.client);
            return this.getShortUrl(url);
        });
    }
    /**
     * Generates a URL for registering a new WebAuth passkey.
     * @param {GetWebAuthUrlForLoginParams} opts the options object
     * @returns - the URL for creating a new passkey
     */
    getWebAuthURLForLogin(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.constructPortalUrl('loginAuth', opts);
        });
    }
    /**
     * Generates a URL for registering a new user password.
     * @param {GetWebAuthUrlForLoginParams} opts the options object
     * @returns - the URL for creating a new password
     */
    getPasswordURLForLogin(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.constructPortalUrl('loginPassword', opts);
        });
    }
    /**
     * Generates a URL for registering a new WebAuth passkey for a phone number.
     * @param {Omit<GetWebAuthUrlForLoginParams, 'authType'>} opts the options object
     * @returns - web auth url
     */
    getWebAuthURLForLoginForPhone(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.constructPortalUrl('loginAuth', Object.assign({ authType: 'phone' }, opts));
        });
    }
    /**
     * Gets the private key for the given wallet.
     * @param {string } [walletId] id of the wallet to get the private key for. Will default to the first wallet if not provided.
     * @returns - the private key string.
     */
    getPrivateKey(walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallets = Object.values(this.wallets);
            const wallet = walletId ? this.wallets[walletId] : wallets === null || wallets === void 0 ? void 0 : wallets[0];
            if (!wallet) {
                throw new Error('wallet not found');
            }
            // We can only build the private key for DKLS wallets
            if (wallet.scheme !== user_management_client_1.WalletScheme.DKLS) {
                throw new Error('invalid wallet scheme');
            }
            return yield this.platformUtils.getPrivateKey(this.ctx, this.userId, wallet.id, wallet.signer, this.retrieveSessionCookie());
        });
    }
    /**
     * Fetches the wallets associated with the user.
     * @returns {WalletEntity[]} wallets that were fetched.
     */
    fetchWallets() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield (this.isPortal() || this.isParaConnect()
                ? this.ctx.client.getAllWallets(this.userId)
                : this.ctx.client.getWallets(this.userId, true));
            return res.data.wallets.filter(wallet => !!wallet.address &&
                (this.isParaConnect() || (!this.isParaConnect() && this.isWalletSupported((0, index_js_2.entityToWallet)(wallet)))));
        });
    }
    populateWalletAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.client.getWallets(this.userId, true);
            const wallets = res.data.wallets;
            wallets.forEach(entity => {
                if (this.wallets[entity.id]) {
                    this.wallets[entity.id] = Object.assign(Object.assign({}, (0, index_js_2.entityToWallet)(entity)), this.wallets[entity.id]);
                }
            });
            yield this.setWallets(this.wallets);
        });
    }
    populatePregenWalletAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.getPregenWallets();
            res.forEach(entity => {
                if (this.wallets[entity.id]) {
                    this.wallets[entity.id] = Object.assign(Object.assign({}, (0, index_js_2.entityToWallet)(entity)), this.wallets[entity.id]);
                }
            });
            yield this.setWallets(this.wallets);
        });
    }
    /**
     * Checks if a user exists for an email address.
     * @param {Object} opts the options object
     * @param {string} opts.email the email to check.
     * @returns true if user exists, false otherwise.
     */
    checkIfUserExists({ email }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.client.checkUserExists({ email });
            return res.data.exists;
        });
    }
    /**
     * Checks if a user exists for a phone number.
     * @param {Object} opts the options object
     * @param {string} opts.phone - phone number to check.
     * @param {string} opts.countryCode - the country code.
     * @returns true if user exists, false otherwise.
     */
    checkIfUserExistsByPhone({ phone, countryCode }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.client.checkUserExists({ phone, countryCode });
            return res.data.exists;
        });
    }
    /**
     * Creates a new user.
     * @param {Object} opts the options object
     * @param {string} opts.email the email to use.
     */
    createUser({ email }) {
        return __awaiter(this, void 0, void 0, function* () {
            this.requireApiKey();
            yield this.setEmail(email);
            const { userId } = yield this.ctx.client.createUser(Object.assign({ email: this.email }, this.getVerificationEmailProps()));
            yield this.setUserId(userId);
        });
    }
    /**
     * Creates a new user with a phone number.
     * @param {Object} opts the options object
     * @param {string} opts.phone - the phone number to use for creating the user.
     * @param {string} opts.countryCode - the country code to use for creating the user.
     */
    createUserByPhone({ phone, countryCode }) {
        return __awaiter(this, void 0, void 0, function* () {
            this.requireApiKey();
            yield this.setPhoneNumber(phone, countryCode);
            const { userId } = yield this.ctx.client.createUser({
                phone: this.phone,
                countryCode: this.countryCode,
            });
            yield this.setUserId(userId);
        });
    }
    /**
     * Logs in or creates a new user using an external wallet address.
     * @param {Object} opts the options object
     * @param {string} opts.address the external wallet address to use for identification.
     * @param {WalletType} opts.type type of external wallet to use for identification.
     * @param {string} opts.provider the name of the provider for the external wallet.
     */
    externalWalletLogin(wallet) {
        return __awaiter(this, void 0, void 0, function* () {
            this.requireApiKey();
            const { userId } = yield this.ctx.client.externalWalletLogin({
                externalAddress: wallet.address,
                type: wallet.type,
                externalWalletProvider: wallet.provider,
            });
            yield this.setExternalWallet(wallet);
            yield this.setUserId(userId);
        });
    }
    /**
     * Returns whether or not the user is connected with an external wallet.
     */
    isUsingExternalWallet() {
        return !!Object.keys(this.externalWallets).length;
    }
    /**
     * Passes the email code obtained from the user for verification.
     * @param {Object} opts the options object
     * @param {string} verificationCode the six-digit code to check
     * @returns {string} the web auth url for creating a new credential
     */
    verifyEmail({ verificationCode }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.client.verifyEmail(this.userId, { verificationCode });
            return this.getSetUpBiometricsURL();
        });
    }
    /**
     * Passes the phone code obtained from the user for verification.
     * @param {Object} opts the options object
     * @param {string} verificationCode the six-digit code to check
     * @returns {string} the web auth url for creating a new credential
     */
    verifyPhone({ verificationCode }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.client.verifyPhone(this.userId, { verificationCode });
            return this.getSetUpBiometricsURLForPhone();
        });
    }
    /**
     * Validates the response received from an attempted Telegram login for authenticity, then
     * creates or retrieves the corresponding Para user and prepares the Para instance to sign in with that user.
     * @param authResponse - the response JSON object received from the Telegram widget.
     * @returns `{ isValid: boolean; telegramUserId?: string; userId?: string; isNewUser?: boolean; supportedAuthMethods?: AuthMethod[]; biometricHints?: BiometricLocationHint[] }`
     */
    verifyTelegram(authObject) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.client.verifyTelegram(authObject);
            if (res.isValid) {
                yield this.setUserId(res.userId);
                yield this.setTelegramUserId(res.telegramUserId);
                yield this.touchSession(true);
                if (!this.loginEncryptionKeyPair) {
                    yield this.setLoginEncryptionKeyPair();
                }
            }
            return res;
        });
    }
    /**
     * Performs 2FA verification.
     * @param {Object} opts the options object
     * @param {string} opts.email the email to use for performing a 2FA verification.
     * @param {string} opts.verificationCode the verification code to received via 2FA.
     * @returns {Object} `{ address, initiatedAt, status, userId, walletId }`
     */
    verify2FA({ email, verificationCode }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.client.verify2FA(email, verificationCode);
            return {
                initiatedAt: res.data.initiatedAt,
                status: res.data.status,
                userId: res.data.userId,
                wallets: res.data.wallets,
            };
        });
    }
    /**
     * Performs 2FA verification.
     * @param {Object} opts the options object
     * @param {string} opts.phone the phone number
     * @param {string} opts.countryCode - the country code
     * @param {string} opts.verificationCode - verification code to received via 2FA.
     * @returns {Object} `{ address, initiatedAt, status, userId, walletId }`
     */
    verify2FAForPhone({ phone, countryCode, verificationCode, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.client.verify2FAForPhone(phone, countryCode, verificationCode);
            return {
                initiatedAt: res.data.initiatedAt,
                status: res.data.status,
                userId: res.data.userId,
                wallets: res.data.wallets,
            };
        });
    }
    /**
     * Sets up two-factor authentication for the current user.
     * @returns {string} uri - uri to use for setting up 2FA
     * */
    setup2FA() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.client.setup2FA(this.userId);
            return {
                uri: res.data.uri,
            };
        });
    }
    /**
     * Enables 2FA.
     * @param {Object} opts the options object
     * @param {string} opts.verificationCode - the verification code received via 2FA.
     */
    enable2FA({ verificationCode }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.client.enable2FA(this.userId, verificationCode);
        });
    }
    /**
     * Determines if 2FA has been set up.
     * @returns {Object} `{ isSetup: boolean }` - true if 2FA is setup, false otherwise
     */
    check2FAStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.userId) {
                return { isSetup: false };
            }
            const res = yield this.ctx.client.check2FAStatus(this.userId);
            return {
                isSetup: res.data.isSetup,
            };
        });
    }
    /**
     * Resend a verification email for the current user.
     */
    resendVerificationCode() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.client.resendVerificationCode(Object.assign({ userId: this.userId }, this.getVerificationEmailProps()));
        });
    }
    /**
     * Resend a verification SMS for the current user.
     */
    resendVerificationCodeByPhone() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.client.resendVerificationCodeByPhone({
                userId: this.userId,
            });
        });
    }
    /**
     * Returns a URL for setting up a new WebAuth passkey.
     * @param {Object} opts the options object
     * @param {string} opts.authType - the auth type to use
     * @param {boolean} opts.isForNewDevice whether the passkey is for a new device of an existing user
     * @returns {string} the URL
     */
    getSetUpBiometricsURL({ authType = 'email', isForNewDevice = false, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.client.addSessionPublicKey(this.userId, {
                status: user_management_client_1.PublicKeyStatus.PENDING,
                type: user_management_client_1.PublicKeyType.WEB,
            });
            return this.getWebAuthURLForCreate({
                authType,
                isForNewDevice,
                webAuthId: res.data.id,
                partnerId: res.data.partnerId,
            });
        });
    }
    /**
     * Returns a URL for setting up a new WebAuth passkey for a phone number.
     * @param {Object} opts the options object
     * @param {boolean} opts.isForNewDevice whether the passkey is for a new device of an existing user
     * @returns {string} the URL
     */
    getSetUpBiometricsURLForPhone({ isForNewDevice = false, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.client.addSessionPublicKey(this.userId, {
                status: user_management_client_1.PublicKeyStatus.PENDING,
                type: user_management_client_1.PublicKeyType.WEB,
            });
            return this.getWebAuthURLForCreate({
                authType: 'phone',
                isForNewDevice,
                webAuthId: res.data.id,
                partnerId: res.data.partnerId,
            });
        });
    }
    /**
     * Returns a URL for setting up a new password.
     * @param {Object} opts the options object
     * @param {string} opts.authType - the auth type to use
     * @param {boolean} opts.isForNewDevice whether the passkey is for a new device of an existing user
     * @param {Theme} [opts.theme] the portal theme to use in place of the partner's default
     * @returns {string} the URL
     */
    getSetupPasswordURL({ authType = 'email', isForNewDevice = false, theme, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.client.addSessionPasswordPublicKey(this.userId, {
                status: user_management_client_1.PasswordStatus.PENDING,
            });
            return this.getPasswordURLForCreate({
                authType,
                isForNewDevice,
                passwordId: res.data.id,
                partnerId: res.data.partnerId,
                theme,
            });
        });
    }
    /**
     * Checks if the current session is active.
     * @returns `true` if active, `false` otherwise
     */
    isSessionActive() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isUsingExternalWallet()) {
                return true;
            }
            const res = yield this.touchSession();
            return !!res.data.isAuthenticated;
        });
    }
    /**
     * Checks if a session is active and a wallet exists.
     * @returns `true` if active, `false` otherwise
     **/
    isFullyLoggedIn() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isUsingExternalWallet()) {
                return true;
            }
            const isSessionActive = yield this.isSessionActive();
            return (isSessionActive &&
                this.currentWalletIdsArray.length > 0 &&
                this.currentWalletIdsArray.reduce((acc, [id]) => acc && !!this.wallets[id], true));
        });
    }
    supportedAuthMethods(auth) {
        return __awaiter(this, void 0, void 0, function* () {
            const { supportedAuthMethods } = yield this.ctx.client.getSupportedAuthMethods(auth);
            const authMethods = new Set();
            for (const type of supportedAuthMethods) {
                switch (type) {
                    case 'PASSWORD':
                        authMethods.add(user_management_client_1.AuthMethod.PASSWORD);
                        break;
                    case 'BIOMETRIC':
                        authMethods.add(user_management_client_1.AuthMethod.PASSKEY);
                        break;
                }
            }
            return authMethods;
        });
    }
    /**
     * Get hints associated with the users stored biometrics.
     * @returns Array containing useragents and AAGuids for stored biometrics
     */
    getUserBiometricLocationHints() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.email && !this.phone && !this.farcasterUsername && !this.telegramUserId) {
                throw new Error('one of email, phone or farcaster username are required to get biometric location hints');
            }
            return yield this.ctx.client.getBiometricLocationHints({
                email: this.email,
                phone: this.phone,
                countryCode: this.countryCode,
                farcasterUsername: this.farcasterUsername,
                telegramUserId: this.telegramUserId,
            });
        });
    }
    setAuth(auth) {
        return __awaiter(this, void 0, void 0, function* () {
            const authInfo = (0, user_management_client_1.extractAuthInfo)(auth);
            if (!authInfo) {
                return undefined;
            }
            switch (authInfo.authType) {
                case 'email':
                    yield this.setEmail(authInfo.identifier);
                    break;
                case 'phone':
                    yield this.setPhoneNumber(authInfo.auth.phone, authInfo.auth.countryCode);
                    break;
                case 'farcaster':
                    yield this.setFarcasterUsername(authInfo.identifier);
                    break;
                case 'telegram':
                    yield this.setTelegramUserId(authInfo.identifier);
                    break;
            }
            return authInfo;
        });
    }
    /**
     * Initiates a login.
     * @param {Object} opts the options object
     * @param {String} opts.email - the email to login with
     * @param {boolean} opts.useShortURL - whether to shorten the link
     * @returns - the WebAuth URL for logging in
     **/
    initiateUserLogin(_a) {
        var { useShortUrl = false } = _a, auth = __rest(_a, ["useShortUrl"]);
        return __awaiter(this, void 0, void 0, function* () {
            const authInfo = yield this.setAuth(auth);
            if (!authInfo) {
                return;
            }
            const res = yield this.touchSession(true);
            if (!this.loginEncryptionKeyPair) {
                yield this.setLoginEncryptionKeyPair();
            }
            const webAuthLoginURL = yield this.getWebAuthURLForLogin({
                authType: authInfo.authType,
                sessionId: res.data.sessionId,
                partnerId: res.data.partnerId,
                loginEncryptionPublicKey: (0, utils_js_1.getPublicKeyHex)(this.loginEncryptionKeyPair),
            });
            if (!useShortUrl) {
                return webAuthLoginURL;
            }
            return this.shortenLoginLink(webAuthLoginURL);
        });
    }
    /**
     * Initiates a login.
     * @param email - the email to login with
     * @returns - a set of supported auth methods for the user
     **/
    initiateUserLoginV2(auth) {
        return __awaiter(this, void 0, void 0, function* () {
            const authInfo = yield this.setAuth(auth);
            if (!authInfo) {
                return;
            }
            yield this.touchSession(true);
            if (!this.loginEncryptionKeyPair) {
                yield this.setLoginEncryptionKeyPair();
            }
            return yield this.supportedAuthMethods(authInfo.auth);
        });
    }
    /**
     * Initiates a login.
     * @param opts the options object
     * @param opts.phone the phone number
     * @param opts.countryCode the country code
     * @param opts.useShortURL - whether to shorten the link
     * @returns - the WebAuth URL for logging in
     **/
    initiateUserLoginForPhone(_a) {
        var { useShortUrl = false } = _a, auth = __rest(_a, ["useShortUrl"]);
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setAuth(auth);
            const res = yield this.touchSession(true);
            if (!this.loginEncryptionKeyPair) {
                yield this.setLoginEncryptionKeyPair();
            }
            const webAuthLoginURL = yield this.getWebAuthURLForLoginForPhone({
                sessionId: res.data.sessionId,
                loginEncryptionPublicKey: (0, utils_js_1.getPublicKeyHex)(this.loginEncryptionKeyPair),
                partnerId: res.data.partnerId,
            });
            if (!useShortUrl) {
                return webAuthLoginURL;
            }
            return this.shortenLoginLink(webAuthLoginURL);
        });
    }
    /**
     * Waits for the session to be active.
     **/
    waitForAccountCreation() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.touchSession();
            // Remove external wallets if creating an account with Para
            this.currentExternalWalletAddresses = undefined;
            this.externalWallets = {};
            this.isAwaitingAccountCreation = true;
            while (this.isAwaitingAccountCreation) {
                try {
                    yield new Promise(resolve => setTimeout(resolve, constants.POLLING_INTERVAL_MS));
                    if (yield this.isSessionActive()) {
                        this.isAwaitingAccountCreation = false;
                        (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.ACCOUNT_CREATION_EVENT, true);
                        return true;
                    }
                }
                catch (err) {
                    // want to continue polling on error
                    console.error(err);
                }
            }
            return false;
        });
    }
    waitForPasskeyAndCreateWallet() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.waitForAccountCreation();
            const pregenWallets = yield this.getPregenWallets();
            let recoverySecret, walletIds = {};
            if (pregenWallets.length > 0) {
                recoverySecret = yield this.claimPregenWallets();
                walletIds = this.supportedWalletTypes.reduce((acc, { type }) => {
                    var _a;
                    return Object.assign(Object.assign({}, acc), { [type]: [(_a = pregenWallets.find(w => !!index_js_2.WalletSchemeTypeMap[w.scheme][type])) === null || _a === void 0 ? void 0 : _a.id] });
                }, {});
            }
            // After claiming any pregen wallets, create wallets for the remaining missing types
            const created = yield this.createWalletPerType();
            recoverySecret = recoverySecret !== null && recoverySecret !== void 0 ? recoverySecret : created.recoverySecret;
            walletIds = Object.assign(Object.assign({}, walletIds), created.walletIds);
            const resp = { walletIds, recoverySecret };
            (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.ACCOUNT_SETUP_EVENT, resp);
            return resp;
        });
    }
    /**
     * Initiates a Farcaster login attempt and return the URI for the user to connect.
     * You can create a QR code with this URI that works with Farcaster's mobile app.
     * @return {string} the Farcaster connect URI
     */
    getFarcasterConnectURL() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.logout();
            yield this.touchSession(true);
            const { data: { connect_uri }, } = yield this.ctx.client.initializeFarcasterLogin();
            return connect_uri;
        });
    }
    /**
     * Awaits the response from a user's attempt to log in with Farcaster.
     * If successful, this returns the user's Farcaster username and profile picture and indicates whether the user already exists.
     * @return {Object} `{userExists: boolean; username: string; pfpUrl?: string | null }` - the user's information and whether the user already exists.
     */
    waitForFarcasterStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isAwaitingFarcaster = true;
            while (this.isAwaitingFarcaster) {
                try {
                    yield new Promise(resolve => setTimeout(resolve, constants.POLLING_INTERVAL_MS));
                    const res = yield this.ctx.client.getFarcasterAuthStatus();
                    if (res.data.state === 'completed') {
                        const { userId, userExists, username, pfpUrl } = res.data;
                        yield this.setUserId(userId);
                        yield this.setFarcasterUsername(username);
                        return {
                            userExists,
                            username,
                            pfpUrl,
                        };
                    }
                }
                catch (err) {
                    console.error(err);
                    this.isAwaitingFarcaster = false;
                }
            }
        });
    }
    /**
     * Generates a URL for the user to log in with OAuth using a desire method.
     *
     * @param {Object} opts the options object
     * @param {OAuthMethod} opts.method the third-party service to use for OAuth.
     * @returns {string} the URL for the user to log in with OAuth.
     */
    getOAuthURL({ method }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.logout();
            const res = yield this.touchSession(true);
            return (0, index_js_2.constructUrl)({
                base: method === user_management_client_1.OAuthMethod.TELEGRAM ? (0, index_js_2.getPortalBaseURL)(this.ctx, true) : (0, userManagementClient_js_1.getBaseOAuthUrl)(this.ctx.env),
                path: `/auth/${method.toLowerCase()}`,
                params: {
                    apiKey: this.ctx.apiKey,
                    sessionLookupId: res.data.sessionLookupId,
                },
            });
        });
    }
    /**
     * Awaits the response from a user's attempt to log in with OAuth.
     * If successful, this returns the user's email address and indicates whether the user already exists.
     *
     * @param {Object} opts the options object.
     * @param {Window} [opts.popupWindow] the popup window being used for login.
     * @return {Object} `{ email?: string; isError?: boolean; userExists: boolean; }` the result data
     */
    waitForOAuth({ popupWindow } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isAwaitingOAuth = true;
            while (this.isAwaitingOAuth) {
                try {
                    if (popupWindow === null || popupWindow === void 0 ? void 0 : popupWindow.closed) {
                        return { isError: true, userExists: false };
                    }
                    yield new Promise(resolve => setTimeout(resolve, constants.POLLING_INTERVAL_MS));
                    if (this.isAwaitingOAuth) {
                        const res = yield this.touchSession();
                        if (res.data.userId) {
                            const { userId, email } = res.data;
                            yield this.setUserId(userId);
                            yield this.setEmail(email);
                            const userExists = yield this.checkIfUserExists({ email });
                            this.isAwaitingOAuth = false;
                            return {
                                userExists,
                                email,
                            };
                        }
                    }
                }
                catch (err) {
                    console.error(err);
                }
            }
            return { userExists: false };
        });
    }
    /**
     * Waits for the session to be active and sets up the user.
     *
     * @param {Object} opts the options object
     * @param {Window} [opts.popupWindow] the popup window being used for login.
     * @param {boolean} [opts.skipSessionRefresh] whether to skip refreshing the session.
     * @returns {Object} `{ isComplete: boolean; isError: boolean; needsWallet: boolean; partnerId: string; }` the result data
     **/
    waitForLoginAndSetup({ popupWindow, skipSessionRefresh = false, } = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Remove external wallets if logging in with Capsule
            this.currentExternalWalletAddresses = undefined;
            this.externalWallets = {};
            this.isAwaitingLogin = true;
            while (this.isAwaitingLogin) {
                try {
                    yield new Promise(resolve => setTimeout(resolve, constants.POLLING_INTERVAL_MS));
                    if (!(yield this.isSessionActive())) {
                        if (popupWindow === null || popupWindow === void 0 ? void 0 : popupWindow.closed) {
                            const resp = { isComplete: false, isError: true };
                            (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.LOGIN_EVENT, resp, 'failed to setup user');
                            return resp;
                        }
                        continue;
                    }
                    const postLoginData = yield this.userSetupAfterLogin();
                    const needsWallet = (_a = postLoginData.data.needsWallet) !== null && _a !== void 0 ? _a : false;
                    if (!needsWallet) {
                        if (this.currentWalletIdsArray.length === 0) {
                            if (popupWindow === null || popupWindow === void 0 ? void 0 : popupWindow.closed) {
                                const resp = { isComplete: false, isError: true };
                                (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.LOGIN_EVENT, resp, 'failed to setup user');
                                return resp;
                            }
                            else {
                                continue;
                            }
                        }
                    }
                    const fetchedWallets = yield this.fetchWallets();
                    const tempSharesRes = yield this.getTransmissionKeyShares();
                    // need this check for the case where user has logged in but temp encrypted shares
                    // haven't been sent to the backend yet
                    if (tempSharesRes.data.temporaryShares.length === fetchedWallets.length) {
                        yield this.setupAfterLogin({ temporaryShares: tempSharesRes.data.temporaryShares, skipSessionRefresh });
                        yield this.claimPregenWallets();
                        const resp = {
                            isComplete: true,
                            needsWallet: needsWallet || Object.values(this.wallets).length === 0,
                            partnerId: postLoginData.data.partnerId,
                        };
                        (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.LOGIN_EVENT, resp);
                        return resp;
                    }
                }
                catch (err) {
                    // want to continue polling on error
                    console.error(err);
                }
            }
            const resp = { isComplete: false };
            (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.LOGIN_EVENT, resp, 'exitted login without setting up user');
            return resp;
        });
    }
    /**
     * Updates the session with the user management server, possibly
     * opening a popup to refresh the session.
     *
     * @param {Object} opts the options object.
     * @param {boolean} [shouldOpenPopup] - if `true`, the running device will open a popup to reauthenticate the user.
     * @returns a URL for the user to reauthenticate.
     **/
    refreshSession({ shouldOpenPopup = false } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.touchSession(true);
            if (!this.loginEncryptionKeyPair) {
                yield this.setLoginEncryptionKeyPair();
            }
            const link = yield this.getWebAuthURLForLogin({
                sessionId: res.data.sessionId,
                loginEncryptionPublicKey: (0, utils_js_1.getPublicKeyHex)(this.loginEncryptionKeyPair),
            });
            if (shouldOpenPopup) {
                this.platformUtils.openPopup(link);
            }
            return link;
        });
    }
    /**
     * Call this method after login to ensure that the user ID is set
     * internally.
     **/
    userSetupAfterLogin() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.touchSession();
            yield this.setUserId(res.data.userId);
            if (res.data.currentWalletIds && res.data.currentWalletIds !== this.currentWalletIds)
                yield this.setCurrentWalletIds(res.data.currentWalletIds, {
                    sessionLookupId: this.isPortal() ? res.data.sessionLookupId : undefined,
                });
            return res;
        });
    }
    /**
     * Get transmission shares associated with session.
     * @param {Object} opts the options object.
     * @param {boolean} opts.isForNewDevice - true if this device is registering.
     * @returns - transmission keyshares.
     **/
    getTransmissionKeyShares({ isForNewDevice = false } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.touchSession();
            const sessionLookupId = isForNewDevice ? `${res.data.sessionLookupId}-new-device` : res.data.sessionLookupId;
            return this.ctx.client.getTransmissionKeyshares(this.userId, sessionLookupId);
        });
    }
    /**
     * Call this method after login to perform setup.
     * @param {Object} opts the options object.
     * @param {any[]} opts.temporaryShares optional temporary shares to use for decryption.
     * @param {boolean} [opts.skipSessionRefresh] - whether or not to skip refreshing the session.
     **/
    setupAfterLogin({ temporaryShares, skipSessionRefresh = false, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!temporaryShares) {
                temporaryShares = (yield this.getTransmissionKeyShares()).data.temporaryShares;
            }
            temporaryShares.forEach(share => {
                const signer = (0, utils_js_1.decryptWithPrivateKey)(this.loginEncryptionKeyPair.privateKey, share.encryptedShare, share.encryptedKey);
                this.wallets[share.walletId] = {
                    id: share.walletId,
                    signer,
                };
            });
            yield this.deleteLoginEncryptionKeyPair();
            yield this.populateWalletAddresses();
            yield this.touchSession(!skipSessionRefresh);
        });
    }
    /**
     * Distributes a new wallet recovery share.
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the wallet to distribute the recovery share for.
     * @param {string} opts.userShare optional user share generate the recovery share from. Defaults to the signer from the passed in walletId
     * @param {boolean} opts.skipBiometricShareCreation whether or not to skip biometric share creation. Used when regenerating recovery shares.
     * @param {boolean} opts.forceRefreshRecovery whether or not to force recovery secret regeneration. Used when regenerating recovery shares.
     * @returns {string} the recovery share.
     **/
    distributeNewWalletShare({ walletId, userShare, skipBiometricShareCreation = false, forceRefresh = false, }) {
        return __awaiter(this, void 0, void 0, function* () {
            let userSigner = userShare;
            if (!userSigner) {
                userSigner = this.wallets[walletId].signer;
            }
            const recoveryShare = skipBiometricShareCreation
                ? yield (0, recovery_js_1.sendRecoveryForShare)({
                    ctx: this.ctx,
                    userId: this.userId,
                    walletId,
                    userSigner,
                    emailProps: this.getBackupKitEmailProps(),
                    forceRefresh,
                })
                : yield (0, shareDistribution_js_1.distributeNewShare)({
                    ctx: this.ctx,
                    userId: this.userId,
                    walletId,
                    userShare: userSigner,
                    emailProps: this.getBackupKitEmailProps(),
                });
            return recoveryShare;
        });
    }
    waitForWalletAddress(walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            let maxPolls = 0;
            while (true) {
                try {
                    if (maxPolls === 10) {
                        break;
                    }
                    ++maxPolls;
                    const res = yield this.ctx.client.getWallets(this.userId);
                    const wallet = res.data.wallets.find(w => w.id === walletId);
                    if (wallet && wallet.address) {
                        return;
                    }
                    yield new Promise(resolve => setTimeout(resolve, constants.SHORT_POLLING_INTERVAL_MS));
                }
                catch (err) {
                    // want to continue polling on error
                    console.error(err);
                }
            }
            throw new Error('timed out waiting for wallet address');
        });
    }
    /**
     * Waits for a pregen wallet address to be created.
     *
     * @param pregenIdentifier - the identifier of the user the pregen wallet is associated with.
     * @param walletId - the wallet id
     * @param pregenIdentifierType - the identifier type of the user the pregen wallet is associated with.
     * @returns - recovery share.
     **/
    waitForPregenWalletAddress(walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            let maxPolls = 0;
            while (true) {
                try {
                    if (maxPolls === 10) {
                        break;
                    }
                    ++maxPolls;
                    const res = yield this.getPregenWallets();
                    const wallet = res.find(w => w.id === walletId);
                    if (wallet && wallet.address) {
                        return;
                    }
                    yield new Promise(resolve => setTimeout(resolve, constants.SHORT_POLLING_INTERVAL_MS));
                }
                catch (err) {
                    // want to continue polling on error
                    console.error(err);
                }
            }
            throw new Error('timed out waiting for wallet address');
        });
    }
    /**
     * Creates several new wallets with the desired types. If no types are provided, this method
     * will create one for each of the non-optional types specified in the instance's `supportedWalletTypes`
     * object that are not already present. This is automatically called upon account creation to ensure that
     * the user has a wallet of each required type.
     *
     * @param {Object} [opts] the options object.
     * @param {boolean} [opts.skipDistribute] if `true`, the wallets' recovery share will not be distributed.
     * @param {WalletType[]} [opts.types] the types of wallets to create.
     * @returns {Object} the wallets created, their ids, and the recovery secret.
     **/
    createWalletPerType({ skipDistribute = false, types, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallets = [];
            const walletIds = {};
            let recoverySecret;
            for (const type of yield this.getTypesToCreate(types)) {
                const [wallet, recoveryShare] = yield this.createWallet({ type, skipDistribute });
                wallets.push(wallet);
                (0, index_js_2.getEquivalentTypes)(type)
                    .filter(t => !!this.isWalletTypeEnabled[t])
                    .forEach(t => {
                    walletIds[t] = [wallet.id];
                });
                if (recoveryShare) {
                    recoverySecret = recoveryShare;
                }
            }
            return { wallets, walletIds, recoverySecret };
        });
    }
    /**
     * Refresh the current user share for a wallet.
     *
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the wallet id to refresh.
     * @param {string} opts.share the current user share.
     * @param {string} [opts.oldPartnerId] the current partner id.
     * @param {string} [opts.newPartnerId] the new partner id to set, if any.
     * @param {string} [opts.keyShareProtocolId]
     * @param {boolean} [opts.redistributeBackupEncryptedShares] whether or not to redistribute backup encrypted shares.
     * @returns {Object} the new user share and recovery secret.
     **/
    refreshShare({ walletId, share, oldPartnerId, newPartnerId, keyShareProtocolId, redistributeBackupEncryptedShares, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { signer, protocolId } = yield this.platformUtils.refresh(this.ctx, this.retrieveSessionCookie(), this.userId, walletId, share, oldPartnerId, newPartnerId, keyShareProtocolId);
            const recoverySecret = yield (0, shareDistribution_js_1.distributeNewShare)({
                ctx: this.ctx,
                userId: this.userId,
                walletId,
                userShare: signer,
                ignoreRedistributingBackupEncryptedShare: !redistributeBackupEncryptedShares,
                emailProps: this.getBackupKitEmailProps(),
                partnerId: newPartnerId,
                protocolId,
            });
            return { signer, recoverySecret, protocolId };
        });
    }
    /**
     * Creates a new wallet.
     * @param {Object} opts the options object.
     * @param {WalletType} opts.type the type of wallet to create.
     * @param {boolean} opts.skipDistribute - if true, recovery share will not be distributed.
     * @returns {[Wallet, string | null]} `[wallet, recoveryShare]` - the wallet object and the new recovery share.
     **/
    createWallet({ type: _type, skipDistribute = false, } = {}) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.requireApiKey();
            const walletType = yield this.assertIsValidWalletType(_type !== null && _type !== void 0 ? _type : (_a = this.supportedWalletTypes.find(({ optional }) => !optional)) === null || _a === void 0 ? void 0 : _a.type);
            let signer;
            let wallet;
            let keygenRes;
            switch (walletType) {
                case user_management_client_1.WalletType.SOLANA: {
                    keygenRes = yield this.platformUtils.ed25519Keygen(this.ctx, this.userId, this.retrieveSessionCookie(), this.getBackupKitEmailProps());
                    break;
                }
                default: {
                    keygenRes = yield this.platformUtils.keygen(this.ctx, this.userId, walletType, null, this.retrieveSessionCookie(), this.getBackupKitEmailProps());
                    break;
                }
            }
            const walletId = keygenRes.walletId;
            signer = keygenRes.signer;
            this.wallets[walletId] = {
                id: walletId,
                signer,
                scheme: walletType === user_management_client_1.WalletType.SOLANA ? user_management_client_1.WalletScheme.ED25519 : user_management_client_1.WalletScheme.DKLS,
                type: walletType,
            };
            wallet = this.wallets[walletId];
            yield this.waitForWalletAddress(wallet.id);
            yield this.populateWalletAddresses();
            let recoveryShare = null;
            if (!skipDistribute) {
                recoveryShare = yield (0, shareDistribution_js_1.distributeNewShare)({
                    ctx: this.ctx,
                    userId: this.userId,
                    walletId: wallet.id,
                    userShare: signer,
                    emailProps: this.getBackupKitEmailProps(),
                });
            }
            yield this.setCurrentWalletIds(Object.assign(Object.assign({}, this.currentWalletIds), { [walletType]: [...((_b = this.currentWalletIds[walletType]) !== null && _b !== void 0 ? _b : []), walletId] }));
            const walletNoSigner = Object.assign({}, wallet);
            delete walletNoSigner.signer;
            (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.WALLET_CREATED, {
                wallet: walletNoSigner,
                recoverySecret: recoveryShare,
            });
            return [wallet, recoveryShare];
        });
    }
    /**
     * Creates a new pregenerated wallet.
     *
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier the identifier associated with the new wallet.
     * @param {TPregenIdentifierType} [opts.pregenIdentifierType] the identifier type. Defaults to `EMAIL`.
     * @param {WalletType} [opts.type] the type of wallet to create. Defaults to the first non-optional type in the instance's `supportedWalletTypes` array.
     * @returns {Wallet} the created wallet.
     **/
    createPregenWallet(opts) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const { type: _type = (_a = this.supportedWalletTypes.find(({ optional }) => !optional)) === null || _a === void 0 ? void 0 : _a.type, pregenIdentifier, pregenIdentifierType = 'EMAIL', } = opts;
            this.requireApiKey();
            const walletType = yield this.assertIsValidWalletType(_type !== null && _type !== void 0 ? _type : (_b = this.supportedWalletTypes.find(({ optional }) => !optional)) === null || _b === void 0 ? void 0 : _b.type);
            let keygenRes;
            switch (walletType) {
                case user_management_client_1.WalletType.SOLANA:
                    keygenRes = yield this.platformUtils.ed25519PreKeygen(this.ctx, pregenIdentifier, pregenIdentifierType, this.retrieveSessionCookie());
                    break;
                default:
                    keygenRes = yield this.platformUtils.preKeygen(this.ctx, undefined, pregenIdentifier, pregenIdentifierType, walletType, null, this.retrieveSessionCookie());
                    break;
            }
            const { signer, walletId } = keygenRes;
            this.wallets[walletId] = {
                id: walletId,
                signer,
                scheme: walletType === user_management_client_1.WalletType.SOLANA ? user_management_client_1.WalletScheme.ED25519 : user_management_client_1.WalletScheme.DKLS,
                type: walletType,
                isPregen: true,
                pregenIdentifier,
                pregenIdentifierType,
            };
            yield this.waitForPregenWalletAddress(walletId);
            yield this.populatePregenWalletAddresses();
            return this.wallets[walletId];
        });
    }
    /**
     * Creates new pregenerated wallets for each desired type.
     * If no types are provided, this method will create one for each of the non-optional types
     * specified in the instance's `supportedWalletTypes` array that are not already present.
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier the identifier to associate each wallet with.
     * @param {TPregenIdentifierType} opts.pregenIdentifierType - either `'EMAIL'` or `'PHONE'`.
     * @param {WalletType[]} [opts.types] the wallet types to create. Defaults to any types the instance supports that are not already present.
     * @returns {Wallet[]} an array containing the created wallets.
     **/
    createPregenWalletPerType({ types, pregenIdentifier, pregenIdentifierType = 'EMAIL', }) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallets = [];
            for (const type of yield this.getTypesToCreate(types)) {
                const wallet = yield this.createPregenWallet({ type, pregenIdentifier, pregenIdentifierType });
                wallets.push(wallet);
            }
            return wallets;
        });
    }
    /**
     * Claims a pregenerated wallet.
     *
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier string the identifier of the user claiming the wallet
     * @param {TPregenIdentifierType} opts.pregenIdentifierType type of the identifier of the user claiming the wallet
     * @returns {[Wallet, string | null]} `[wallet, recoveryShare]` - the wallet object and the new recovery share.
     **/
    claimPregenWallets({ pregenIdentifier, pregenIdentifierType = !!pregenIdentifier ? 'EMAIL' : undefined, } = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.requireApiKey();
            const pregenWallets = pregenIdentifier && pregenIdentifierType
                ? yield this.getPregenWallets({ pregenIdentifier, pregenIdentifierType })
                : yield this.getPregenWallets();
            if (pregenWallets.length === 0) {
                return undefined;
            }
            let newRecoverySecret;
            const { walletIds } = yield this.ctx.client.claimPregenWallets({
                userId: this.userId,
                walletIds: pregenWallets.map(w => w.id),
            });
            for (const walletId of walletIds) {
                const wallet = this.wallets[walletId];
                let refreshedShare;
                if (wallet.scheme === user_management_client_1.WalletScheme.ED25519) {
                    const distributeRes = yield (0, shareDistribution_js_1.distributeNewShare)({
                        ctx: this.ctx,
                        userId: this.userId,
                        walletId: wallet.id,
                        userShare: this.wallets[wallet.id].signer,
                        emailProps: this.getBackupKitEmailProps(),
                        partnerId: wallet.partnerId,
                    });
                    if (distributeRes.length > 0) {
                        newRecoverySecret = distributeRes;
                    }
                }
                else {
                    refreshedShare = yield this.refreshShare({
                        walletId: wallet.id,
                        share: this.wallets[wallet.id].signer,
                        oldPartnerId: wallet.partnerId,
                        newPartnerId: wallet.partnerId,
                        redistributeBackupEncryptedShares: true,
                    });
                    if (refreshedShare.recoverySecret) {
                        newRecoverySecret = refreshedShare.recoverySecret;
                    }
                }
                this.wallets[wallet.id] = Object.assign(Object.assign({}, this.wallets[wallet.id]), { signer: (_a = refreshedShare === null || refreshedShare === void 0 ? void 0 : refreshedShare.signer) !== null && _a !== void 0 ? _a : wallet.signer, userId: this.userId, pregenIdentifier: undefined, pregenIdentifierType: undefined });
                const walletNoSigner = Object.assign({}, this.wallets[wallet.id]);
                delete walletNoSigner.signer;
                (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.PREGEN_WALLET_CLAIMED, {
                    wallet: walletNoSigner,
                    recoverySecret: newRecoverySecret,
                });
            }
            yield this.setWallets(this.wallets);
            return newRecoverySecret;
        });
    }
    /**
     * Updates the identifier for a pregen wallet.
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the pregen wallet ID
     * @param {string} opts.newPregenIdentifier the new identtifier
     * @param {TPregenIdentifierType} opts.newPregenIdentifierType: the new identifier type
     **/
    updatePregenWalletIdentifier({ walletId, newPregenIdentifier, newPregenIdentifierType, }) {
        return __awaiter(this, void 0, void 0, function* () {
            this.requireApiKey();
            yield this.ctx.client.updatePregenWallet(walletId, {
                pregenIdentifier: newPregenIdentifier,
                pregenIdentifierType: newPregenIdentifierType,
            });
            if (!!this.wallets[walletId]) {
                this.wallets[walletId] = Object.assign(Object.assign({}, this.wallets[walletId]), { pregenIdentifier: newPregenIdentifier, pregenIdentifierType: newPregenIdentifierType });
                yield this.setWallets(this.wallets);
            }
        });
    }
    /**
     * Checks if a pregen Wallet exists for the given identifier with the current partner.
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier string the identifier of the user claiming the wallet
     * @param {TPregenIdentifierType} opts.pregenIdentifierType type of the string of the identifier of the user claiming the wallet
     * @returns {boolean} whether the pregen wallet exists
     **/
    hasPregenWallet({ pregenIdentifier, pregenIdentifierType, }) {
        return __awaiter(this, void 0, void 0, function* () {
            this.requireApiKey();
            // This function gets pregen wallets by identifier and partnerId
            const res = yield this.getPregenWallets({ pregenIdentifier, pregenIdentifierType });
            const wallet = res.find(w => w.pregenIdentifier === pregenIdentifier && w.pregenIdentifierType === pregenIdentifierType);
            if (!wallet) {
                return false;
            }
            return true;
        });
    }
    /**
     * Get pregen wallets for the given identifier.
     * @param {Object} opts the options object.
     * @param {string} opts.pregenIdentifier - the identifier of the user claiming the wallet
     * @param {TPregenIdentifierType} opts.pregenIdentifierType - type of the identifier of the user claiming the wallet
     * @returns {Promise<WalletEntity[]>} the array of found wallets
     **/
    getPregenWallets({ pregenIdentifier, pregenIdentifierType = !!pregenIdentifier ? 'EMAIL' : undefined, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.requireApiKey();
            const res = yield this.ctx.client.getPregenWallets(pregenIdentifier && pregenIdentifierType ? { [pregenIdentifierType]: [pregenIdentifier] } : this.pregenIds, this.isPortal(), this.userId);
            return res.wallets.filter(w => this.isWalletSupported((0, index_js_2.entityToWallet)(w)));
        });
    }
    encodeWalletBase64(wallet) {
        const walletJson = JSON.stringify(wallet);
        const base64Wallet = Buffer.from(walletJson).toString('base64');
        return base64Wallet;
    }
    /**
     * Encodes the current wallets encoded in Base 64.
     * @returns {string} the encoded wallet string
     **/
    getUserShare() {
        if (Object.values(this.wallets).length === 0) {
            return null;
        }
        return Object.values(this.wallets)
            .map(wallet => this.encodeWalletBase64(wallet))
            .join('-');
    }
    /**
     * Sets the current wallets from a Base 64 string.
     * @param {string} base64Wallet the encoded wallet string
     **/
    setUserShare(base64Wallets) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!base64Wallets) {
                return;
            }
            const base64WalletsSplit = base64Wallets.split('-');
            for (const base64Wallet of base64WalletsSplit) {
                const walletJson = Buffer.from(base64Wallet, 'base64').toString();
                const wallet = (0, index_js_2.migrateWallet)(JSON.parse(walletJson));
                this.wallets[wallet.id] = wallet;
                yield this.setWallets(this.wallets);
            }
        });
    }
    getTransactionReviewUrl(transactionId, timeoutMs) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.touchSession();
            return this.constructPortalUrl('txReview', {
                partnerId: res.data.partnerId,
                pathId: transactionId,
                params: {
                    email: this.email,
                    timeoutMs: timeoutMs === null || timeoutMs === void 0 ? void 0 : timeoutMs.toString(),
                },
            });
        });
    }
    getOnRampTransactionUrl(_a) {
        var { purchaseId, providerKey } = _a, walletParams = __rest(_a, ["purchaseId", "providerKey"]);
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.touchSession();
            const [key, identifier] = (0, user_management_client_1.extractWalletRef)(walletParams);
            return this.constructPortalUrl('onRamp', {
                partnerId: res.data.partnerId,
                pathId: purchaseId,
                sessionId: res.data.sessionId,
                params: {
                    [key]: identifier,
                    providerKey,
                    currentWalletIds: JSON.stringify(this.currentWalletIds),
                },
            });
        });
    }
    /**
     * Signs a message using one of the current wallets.
     *
     * If you want to sign the keccak256 hash of a message, hash the
     * message first and then pass in the base64 encoded hash.
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the id of the wallet to sign with.
     * @param {string} opts.messageBase64 the base64 encoding of exact message that should be signed
     * @param {number} [opts.timeout] optional timeout in milliseconds. If not present, defaults to 30 seconds.
     * @param {string} [opts.cosmosSignDocBase64] the Cosmos `SignDoc` in base64, if applicable
     **/
    signMessage({ walletId, messageBase64, timeoutMs = 30000, cosmosSignDocBase64, }) {
        return __awaiter(this, void 0, void 0, function* () {
            this.assertIsValidWalletId(walletId);
            const wallet = this.wallets[walletId];
            let signerId = this.userId;
            if (wallet.partnerId && !wallet.userId) {
                signerId = wallet.partnerId;
            }
            let signRes = yield this.signMessageInner({ wallet, signerId, messageBase64, cosmosSignDocBase64 });
            let timeStart = Date.now();
            if (signRes.pendingTransactionId) {
                this.platformUtils.openPopup(yield this.getTransactionReviewUrl(signRes.pendingTransactionId, timeoutMs), { type: cosmosSignDocBase64 ? index_js_1.PopupType.SIGN_TRANSACTION_REVIEW : index_js_1.PopupType.SIGN_MESSAGE_REVIEW });
            }
            else {
                (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.SIGN_MESSAGE_EVENT, signRes);
                return signRes;
            }
            yield new Promise(resolve => setTimeout(resolve, constants.POLLING_INTERVAL_MS));
            while (true) {
                if (Date.now() - timeStart > timeoutMs) {
                    break;
                }
                try {
                    yield this.ctx.client.getPendingTransaction(this.userId, signRes.pendingTransactionId);
                }
                catch (err) {
                    const error = new errors_js_1.TransactionReviewDenied();
                    (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.SIGN_MESSAGE_EVENT, signRes, error.message);
                    throw error;
                }
                signRes = yield this.signMessageInner({ wallet, signerId, messageBase64, cosmosSignDocBase64 });
                if (signRes.pendingTransactionId) {
                    yield new Promise(resolve => setTimeout(resolve, constants.POLLING_INTERVAL_MS));
                }
                else {
                    break;
                }
            }
            if (signRes.pendingTransactionId) {
                const error = new errors_js_1.TransactionReviewTimeout(yield this.getTransactionReviewUrl(signRes.pendingTransactionId), signRes.pendingTransactionId);
                (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.SIGN_MESSAGE_EVENT, signRes, error.message);
                throw error;
            }
            (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.SIGN_MESSAGE_EVENT, signRes);
            return signRes;
        });
    }
    signMessageInner({ wallet, signerId, messageBase64, cosmosSignDocBase64, }) {
        return __awaiter(this, void 0, void 0, function* () {
            let signRes;
            switch (wallet.scheme) {
                case user_management_client_1.WalletScheme.ED25519:
                    signRes = yield this.platformUtils.ed25519Sign(this.ctx, signerId, wallet.id, wallet.signer, messageBase64, this.retrieveSessionCookie());
                    break;
                default:
                    signRes = yield this.platformUtils.signMessage(this.ctx, signerId, wallet.id, wallet.signer, messageBase64, this.retrieveSessionCookie(), wallet.scheme === user_management_client_1.WalletScheme.DKLS, cosmosSignDocBase64);
                    break;
            }
            return signRes;
        });
    }
    /**
     * Signs a transaction.
     * @param {Object} opts the options object.
     * @param {string} opts.walletId the id of the wallet to sign with.
     * @param {string} opts.rlpEncodedTxBase64 the transaction to sign, in RLP base64 encoding
     * @param {string} [opts.chainId] the EVM chain id of the chain the transaction is being sent on, if applicable
     * @param {number} [opts.timeoutMs] the amount of time to wait for the user to sign the transaction, in milliseconds
     **/
    signTransaction({ walletId, rlpEncodedTxBase64, chainId, timeoutMs = 30000, }) {
        return __awaiter(this, void 0, void 0, function* () {
            this.assertIsValidWalletId(walletId);
            const wallet = this.wallets[walletId];
            let signerId = this.userId;
            if (wallet.partnerId && !wallet.userId) {
                signerId = wallet.partnerId;
            }
            let signRes = yield this.platformUtils.signTransaction(this.ctx, signerId, walletId, this.wallets[walletId].signer, rlpEncodedTxBase64, chainId, this.retrieveSessionCookie(), wallet.scheme === user_management_client_1.WalletScheme.DKLS);
            let timeStart = Date.now();
            if (signRes.pendingTransactionId) {
                this.platformUtils.openPopup(yield this.getTransactionReviewUrl(signRes.pendingTransactionId, timeoutMs), { type: index_js_1.PopupType.SIGN_TRANSACTION_REVIEW });
            }
            else {
                (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.SIGN_TRANSACTION_EVENT, signRes);
                return signRes;
            }
            yield new Promise(resolve => setTimeout(resolve, constants.POLLING_INTERVAL_MS));
            while (true) {
                if (Date.now() - timeStart > timeoutMs) {
                    break;
                }
                try {
                    yield this.ctx.client.getPendingTransaction(this.userId, signRes.pendingTransactionId);
                }
                catch (err) {
                    const error = new errors_js_1.TransactionReviewDenied();
                    (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.SIGN_TRANSACTION_EVENT, signRes, error.message);
                    throw error;
                }
                signRes = yield this.platformUtils.signTransaction(this.ctx, signerId, walletId, this.wallets[walletId].signer, rlpEncodedTxBase64, chainId, this.retrieveSessionCookie(), wallet.scheme === user_management_client_1.WalletScheme.DKLS);
                if (signRes.pendingTransactionId) {
                    yield new Promise(resolve => setTimeout(resolve, constants.POLLING_INTERVAL_MS));
                }
                else {
                    break;
                }
            }
            if (signRes.pendingTransactionId) {
                const error = new errors_js_1.TransactionReviewTimeout(yield this.getTransactionReviewUrl(signRes.pendingTransactionId), signRes.pendingTransactionId);
                (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.SIGN_TRANSACTION_EVENT, signRes, error.message);
                throw error;
            }
            (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.SIGN_TRANSACTION_EVENT, signRes);
            return signRes;
        });
    }
    /**
     * @deprecated
     * Sends a transaction.
     * @param walletId - id of the wallet to send the transaction from.
     * @param rlpEncodedTxBase64 - rlp encoded tx as base64 string
     * @param chainId - chain id of the chain the transaction is being sent on.
     **/
    sendTransaction({ walletId, rlpEncodedTxBase64, chainId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            this.assertIsValidWalletId(walletId);
            const wallet = this.wallets[walletId];
            const signRes = yield this.platformUtils.sendTransaction(this.ctx, this.userId, walletId, this.wallets[walletId].signer, rlpEncodedTxBase64, chainId, this.retrieveSessionCookie(), wallet.scheme === user_management_client_1.WalletScheme.DKLS);
            if (signRes.pendingTransactionId) {
                this.platformUtils.openPopup(yield this.getTransactionReviewUrl(signRes.pendingTransactionId), { type: index_js_1.PopupType.SIGN_TRANSACTION_REVIEW });
                const error = new errors_js_1.TransactionReviewError(yield this.getTransactionReviewUrl(signRes.pendingTransactionId));
                throw error;
            }
            return signRes;
        });
    }
    isProviderModalDisabled() {
        return !!this.disableProviderModal;
    }
    /**
     * Starts a on-ramp or off-ramp transaction and returns the Para Portal link for the user to finalize and complete it.
     * @param {Object} opts the options object
     * @param {OnRampPurchaseCreateParams} opts.params the transaction settings.
     * @param {boolean} opts.shouldOpenPopup if `true`, a popup window with the link will be opened.
     * @param {string} opts.walletId the wallet ID to use for the transaction, where funds will be sent or withdrawn.
     * @param {string} opts.externalWalletAddress the external wallet address to send funds to or withdraw funds from, if using an external wallet.
     **/
    initiateOnRampTransaction(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { params, shouldOpenPopup } = options, walletParams = __rest(options, ["params", "shouldOpenPopup"]);
            const onRampPurchase = yield this.ctx.client.createOnRampPurchase(Object.assign({ userId: this.userId, params: Object.assign(Object.assign({}, params), { address: (_a = walletParams.externalWalletAddress) !== null && _a !== void 0 ? _a : this.getDisplayAddress(walletParams.walletId, { addressType: params.walletType }) }) }, walletParams));
            const portalUrl = yield this.getOnRampTransactionUrl(Object.assign({ purchaseId: onRampPurchase.id, providerKey: onRampPurchase.providerKey }, walletParams));
            if (shouldOpenPopup) {
                this.platformUtils.openPopup(portalUrl, { type: index_js_1.PopupType.ON_RAMP_TRANSACTION });
            }
            return { onRampPurchase, portalUrl };
        });
    }
    /**
     * Returns `true` if session was successfully kept alive, `false` otherwise.
     **/
    keepSessionAlive() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.ctx.client.keepSessionAlive(this.userId);
                return true;
            }
            catch (err) {
                return false;
            }
        });
    }
    /**
     * Serialize the current session for import by another Para instance.
     * @returns {string} the serialized session
     */
    exportSession() {
        const sessionInfo = {
            email: this.email,
            userId: this.userId,
            wallets: this.wallets,
            currentWalletIds: this.currentWalletIds,
            sessionCookie: this.sessionCookie,
            phone: this.phone,
            countryCode: this.countryCode,
        };
        return Buffer.from(JSON.stringify(sessionInfo)).toString('base64');
    }
    /**
     * Imports a session serialized by another Para instance.
     * @param {string} serializedInstanceBase64 the serialized session
     */
    importSession(serializedInstanceBase64) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const serializedInstance = Buffer.from(serializedInstanceBase64, 'base64').toString('utf8');
            const sessionInfo = JSON.parse(serializedInstance);
            yield this.setEmail(sessionInfo.email);
            yield this.setUserId(sessionInfo.userId);
            yield this.setWallets(sessionInfo.wallets);
            for (const walletId of Object.keys(this.wallets)) {
                if (!this.wallets[walletId].userId) {
                    this.wallets[walletId].userId = this.userId;
                }
            }
            if (Object.keys(sessionInfo.currentWalletIds).length !== 0) {
                yield this.setCurrentWalletIds(sessionInfo.currentWalletIds);
            }
            else {
                const currentWalletIds = {};
                for (const walletId of Object.keys(sessionInfo.wallets)) {
                    currentWalletIds[sessionInfo.wallets[walletId].type] = [
                        ...((_a = currentWalletIds[sessionInfo.wallets[walletId].type]) !== null && _a !== void 0 ? _a : []),
                        walletId,
                    ];
                }
                yield this.setCurrentWalletIds(currentWalletIds);
            }
            this.persistSessionCookie(sessionInfo.sessionCookie);
            yield this.setPhoneNumber(sessionInfo.phone, sessionInfo.countryCode);
        });
    }
    exitAccountCreation() {
        this.isAwaitingAccountCreation = false;
    }
    exitLogin() {
        this.isAwaitingLogin = false;
    }
    exitFarcaster() {
        this.isAwaitingFarcaster = false;
    }
    exitOAuth() {
        this.isAwaitingOAuth = false;
    }
    exitLoops() {
        this.exitAccountCreation();
        this.exitLogin();
        this.exitFarcaster();
        this.exitOAuth();
    }
    /**
     * Logs the user out.
     * @param {Object} opts the options object.
     * @param {boolean} opts.clearPregenWallets if `true`, will remove all pregen wallets from storage
     **/
    logout({ clearPregenWallets = false } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.client.logout();
            yield this.clearStorage();
            if (!clearPregenWallets) {
                Object.entries(this.wallets).forEach(([id, wallet]) => {
                    if (!wallet.pregenIdentifier) {
                        delete this.wallets[id];
                    }
                });
                yield this.setWallets(this.wallets);
            }
            else {
                this.wallets = {};
            }
            this.currentWalletIds = {};
            this.currentExternalWalletAddresses = undefined;
            this.externalWallets = {};
            this.loginEncryptionKeyPair = undefined;
            this.email = undefined;
            this.telegramUserId = undefined;
            this.phone = undefined;
            this.countryCode = undefined;
            this.userId = undefined;
            this.sessionCookie = undefined;
            (0, index_js_2.dispatchEvent)(index_js_1.ParaEvent.LOGOUT_EVENT, null);
        });
    }
    getSupportedCreateAuthMethods() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.touchSession();
            const partnerId = res.data.partnerId;
            const partnerRes = yield this.ctx.client.getPartner(partnerId);
            let supportedAuthMethods = new Set();
            for (const authMethod of partnerRes.data.partner.supportedAuthMethods) {
                supportedAuthMethods.add(user_management_client_1.AuthMethod[authMethod]);
            }
            return supportedAuthMethods;
        });
    }
    /**
     * Converts to a string, removing sensitive data when logging this class.
     *
     * Doesn't work for all types of logging.
     **/
    toString() {
        const redactedWallets = Object.keys(this.wallets).reduce((acc, walletId) => (Object.assign(Object.assign({}, acc), { [walletId]: Object.assign(Object.assign({}, this.wallets[walletId]), { signer: this.wallets[walletId].signer ? '[REDACTED]' : undefined }) })), {});
        const obj = {
            supportedWalletTypes: this.supportedWalletTypes,
            cosmosPrefix: this.cosmosPrefix,
            email: this.email,
            phone: this.phone,
            countryCode: this.countryCode,
            telegramUserId: this.telegramUserId,
            farcasterUsername: this.farcasterUsername,
            userId: this.userId,
            pregenIds: this.pregenIds,
            currentWalletIds: this.currentWalletIds,
            wallets: redactedWallets,
            loginEncryptionKeyPair: this.loginEncryptionKeyPair ? '[REDACTED]' : undefined,
            ctx: {
                apiKey: this.ctx.apiKey,
                disableWorkers: this.ctx.disableWorkers,
                disableWebSockets: this.ctx.disableWebSockets,
                env: this.ctx.env,
                offloadMPCComputationURL: this.ctx.offloadMPCComputationURL,
                useLocalFiles: this.ctx.useLocalFiles,
                useDKLS: this.ctx.useDKLS,
                cosmosPrefix: this.ctx.cosmosPrefix,
            },
        };
        return `Para ${JSON.stringify(obj, null, 2)}`;
    }
}
exports.ParaCore = ParaCore;
_ParaCore_supportedWalletTypes = new WeakMap(), _ParaCore_supportedWalletTypesOpt = new WeakMap();
ParaCore.version = constants.PARA_CORE_VERSION;
